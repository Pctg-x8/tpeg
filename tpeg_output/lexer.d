module com.cterm2.ml.lexer;

/// This file is generated by tpeg version 1.0 ///

import std.file;
import std.array, std.range;
import std.conv;

public enum EnumTokenType
{
	INUMBER, HNUMBER, FNUMBER, DNUMBER, NUMBER, DNUMBER2, NUMBER2, STRING, CHARACTER, 
	IDENTIFIER, SEMICOLON, PERIOD, COMMA, COLON, RARROW, RARROW2, LARROW, SHARP, 
	EQUAL, PLUS_EQ, MINUS_EQ, ASTERISK_EQ, SLASH_EQ, PERCENT_EQ, AMPASAND_EQ, VL_EQ, 
	CA_EQ, LAB2_EQ, RAB2_EQ, AMPASAND2, VL2, CA2, PLUS, MINUS, ASTERISK, SLASH, 
	PERCENT, AMPASAND, VL, CA, LAB2, RAB2, LAB, RAB, LAB_EQ, RAB_EQ, EQ2, EX_EQ, 
	QUESTION, PLUS2, MINUS2, ASTERISK2, PERIOD2, PERIOD3, LP, RP, LB, RB, LBR, RBR, 

	// Special Reduce for IDENTIFIER
	PACKAGE, IMPORT, CLASS, TRAIT, ENUM, EXTENDS, WITH, TEMPLATE, ALIAS, USING, 
	PROPERTY, FUNCTION, IF, ELSE, WHILE, DO, FOREACH, FOR, RETURN, BREAK, CONTINUE, 
	SWITCH, CASE, DEFAULT, TYPEOF, THIS, SUPER, TRUE, FALSE, NULL, NEW, PUBLIC, 
	PRIVATE, PROTECTED, FINAL, CONST, STATIC, OVERRIDE, AUTO, VOID, CHAR, UCHAR, 
	BYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, 

	__INPUT_END__
}
public struct Location
{
	size_t line, column;

	public auto toString(){ return this.line.to!string ~ ":" ~ this.column.to!string; }
}
public class Token
{
	Location _loc;
	EnumTokenType _type;
	string _text;

	public @property location(){ return this._loc; }
	public @property type(){ return this._type; }
	public @property text(){ return this._text; }

	public this(Location l, EnumTokenType t)
	{
		this._loc = l;
		this._type = t;
	}
	public this(Location l, EnumTokenType t, string tx)
	{
		this(l, t);
		this._text = tx;
	}

	public @property dup(){ return new Token(this._loc, this._type, this._text); }
}
public class TokenizeError : Exception
{
	public this(string err, Location loc){ super(err ~ " at " ~ loc.toString); }
}

public auto tokenize(string filePath){ return tokenizeStr(filePath.readText()); }
public auto tokenizeStr(string input)
{
	Token[] tokenList = null;
	auto loc = Location(1, 1), cloc = Location(0, 0);
	auto inputRange = input[];
	string inputHolder = null;
	size_t currentState = 0;
	void forward()
	{
		if(inputRange.front == '\n'){ loc.line++; loc.column = 1; }
		else if(inputRange.front == '\t') loc.column += loc.column % 4 + 1;
		else loc.column++;
		auto t = inputRange[1 .. $];
		inputRange = t;
	}
	while(!inputRange.empty)
	{
		switch(currentState)
		{
		case 0: 
			switch(inputRange.front)
			{
			case ' ': 
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '\t': 
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '\r': 
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '\n': 
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '/': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 1;
				break;
			case '*': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 22;
				break;
			case '=': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 18;
				break;
			case '0': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 5;
				break;
			case '.': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 11;
				break;
			case 'F': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'f': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'D': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'd': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case '1': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '2': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '3': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '4': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '5': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '6': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '7': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '8': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '9': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case 'x': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'A': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'B': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'C': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'E': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'a': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'b': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'c': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'e': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case '"': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 13;
				break;
			case '\'': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 15;
				break;
			case 'G': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'H': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'I': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'J': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'K': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'L': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'M': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'N': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'O': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'P': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'Q': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'R': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'S': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'T': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'U': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'V': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'W': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'X': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'Y': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'Z': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'g': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'h': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'i': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'j': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'k': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'l': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'm': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'n': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'o': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'p': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'q': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'r': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 's': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 't': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'u': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'v': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'w': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'y': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case 'z': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case '_': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 16;
				break;
			case ';': 
				tokenList ~= new Token(loc, EnumTokenType.SEMICOLON, inputRange.front.to!string);
				forward();
				break;
			case ',': 
				tokenList ~= new Token(loc, EnumTokenType.COMMA, inputRange.front.to!string);
				forward();
				break;
			case ':': 
				tokenList ~= new Token(loc, EnumTokenType.COLON, inputRange.front.to!string);
				forward();
				break;
			case '-': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 17;
				break;
			case '>': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 27;
				break;
			case '<': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 19;
				break;
			case '#': 
				tokenList ~= new Token(loc, EnumTokenType.SHARP, inputRange.front.to!string);
				forward();
				break;
			case '+': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 21;
				break;
			case '%': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 23;
				break;
			case '&': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 24;
				break;
			case '|': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 25;
				break;
			case '^': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 26;
				break;
			case '!': 
				cloc = loc;
				inputHolder ~= inputRange.front;
				forward();
				currentState = 29;
				break;
			case '?': 
				tokenList ~= new Token(loc, EnumTokenType.QUESTION, inputRange.front.to!string);
				forward();
				break;
			case '(': 
				tokenList ~= new Token(loc, EnumTokenType.LP, inputRange.front.to!string);
				forward();
				break;
			case ')': 
				tokenList ~= new Token(loc, EnumTokenType.RP, inputRange.front.to!string);
				forward();
				break;
			case '{': 
				tokenList ~= new Token(loc, EnumTokenType.LB, inputRange.front.to!string);
				forward();
				break;
			case '}': 
				tokenList ~= new Token(loc, EnumTokenType.RB, inputRange.front.to!string);
				forward();
				break;
			case '[': 
				tokenList ~= new Token(loc, EnumTokenType.LBR, inputRange.front.to!string);
				forward();
				break;
			case ']': 
				tokenList ~= new Token(loc, EnumTokenType.RBR, inputRange.front.to!string);
				forward();
				break;
			default: 
				throw new TokenizeError("Unrecognized character: " ~ inputRange.front.to!string, loc);
			}
			break;
		case 1: 
			switch(inputRange.front)
			{
			case '/': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 2;
				break;
			case '*': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 3;
				break;
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.SLASH_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.SLASH, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 2: 
			switch(inputRange.front)
			{
			case '\n': 
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				inputHolder ~= inputRange.front;
				forward();
				break;
			}
			break;
		case 3: 
			switch(inputRange.front)
			{
			case '*': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 4;
				break;
			default: 
				inputHolder ~= inputRange.front;
				forward();
				break;
			}
			break;
		case 4: 
			switch(inputRange.front)
			{
			case '/': 
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				throw new TokenizeError("Unrecognized character: " ~ inputRange.front.to!string, loc);
			}
			break;
		case 5: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '.': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 7;
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 6;
				break;
			case 'x': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 9;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.INUMBER, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 6: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '.': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 7;
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.INUMBER, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 7: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			default: 
				throw new TokenizeError("Unrecognized character: " ~ inputRange.front.to!string, loc);
			}
			break;
		case 8: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'F': 
				tokenList ~= new Token(cloc, EnumTokenType.FNUMBER, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case 'f': 
				tokenList ~= new Token(cloc, EnumTokenType.FNUMBER, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case 'D': 
				tokenList ~= new Token(cloc, EnumTokenType.DNUMBER2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case 'd': 
				tokenList ~= new Token(cloc, EnumTokenType.DNUMBER2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.NUMBER2, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 9: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'F': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'f': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'D': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'd': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'A': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'B': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'C': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'E': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'a': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'b': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'c': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			case 'e': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 10;
				break;
			default: 
				throw new TokenizeError("Unrecognized character: " ~ inputRange.front.to!string, loc);
			}
			break;
		case 10: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'F': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'f': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'D': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'd': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'A': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'B': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'C': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'E': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'a': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'b': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'c': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'e': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.HNUMBER, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 11: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '.': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 12;
				break;
			case 'D': 
				tokenList ~= new Token(cloc, EnumTokenType.DNUMBER2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case 'd': 
				tokenList ~= new Token(cloc, EnumTokenType.DNUMBER2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 8;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.PERIOD, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 12: 
			switch(inputRange.front)
			{
			case '.': 
				tokenList ~= new Token(cloc, EnumTokenType.PERIOD3, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.PERIOD2, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 13: 
			switch(inputRange.front)
			{
			case '"': 
				tokenList ~= new Token(cloc, EnumTokenType.STRING, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '\\': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 14;
				break;
			default: 
				inputHolder ~= inputRange.front;
				forward();
				break;
			}
			break;
		case 14: 
			inputHolder ~= inputRange.front;
			forward();
			currentState = 13;
			break;
		case 15: 
			switch(inputRange.front)
			{
			case '\'': 
				tokenList ~= new Token(cloc, EnumTokenType.CHARACTER, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				inputHolder ~= inputRange.front;
				forward();
				break;
			}
			break;
		case 16: 
			switch(inputRange.front)
			{
			case '0': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'F': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'f': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'D': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'd': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '1': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '2': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '3': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '4': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '5': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '6': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '7': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '8': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '9': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'x': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'A': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'B': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'C': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'E': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'a': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'b': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'c': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'e': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'G': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'H': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'I': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'J': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'K': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'L': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'M': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'N': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'O': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'P': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'Q': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'R': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'S': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'T': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'U': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'V': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'W': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'X': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'Y': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'Z': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'g': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'h': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'i': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'j': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'k': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'l': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'm': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'n': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'o': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'p': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'q': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'r': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 's': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 't': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'u': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'v': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'w': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'y': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case 'z': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			case '_': 
				inputHolder ~= inputRange.front;
				forward();
				break;
			default: 
				tokenList ~= reduceHooker_IDENTIFIER(cloc, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 17: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.MINUS_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '-': 
				tokenList ~= new Token(cloc, EnumTokenType.MINUS2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '>': 
				tokenList ~= new Token(cloc, EnumTokenType.RARROW, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.MINUS, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 18: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.EQ2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '>': 
				tokenList ~= new Token(cloc, EnumTokenType.RARROW2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.EQUAL, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 19: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.LAB_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '-': 
				tokenList ~= new Token(cloc, EnumTokenType.LARROW, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '<': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 20;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.LAB, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 20: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.LAB2_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.LAB2, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 21: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.PLUS_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '+': 
				tokenList ~= new Token(cloc, EnumTokenType.PLUS2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.PLUS, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 22: 
			switch(inputRange.front)
			{
			case '*': 
				tokenList ~= new Token(cloc, EnumTokenType.ASTERISK2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.ASTERISK_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.ASTERISK, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 23: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.PERCENT_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.PERCENT, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 24: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.AMPASAND_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '&': 
				tokenList ~= new Token(cloc, EnumTokenType.AMPASAND2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.AMPASAND, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 25: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.VL_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '|': 
				tokenList ~= new Token(cloc, EnumTokenType.VL2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.VL, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 26: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.CA_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '^': 
				tokenList ~= new Token(cloc, EnumTokenType.CA2, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.CA, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 27: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.RAB_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			case '>': 
				inputHolder ~= inputRange.front;
				forward();
				currentState = 28;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.RAB, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 28: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.RAB2_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				tokenList ~= new Token(cloc, EnumTokenType.RAB2, inputHolder);
				inputHolder = null;
				currentState = 0;
				break;
			}
			break;
		case 29: 
			switch(inputRange.front)
			{
			case '=': 
				tokenList ~= new Token(cloc, EnumTokenType.EX_EQ, inputHolder ~ inputRange.front.to!string);
				forward();
				inputHolder = null;
				currentState = 0;
				break;
			default: 
				throw new TokenizeError("Unrecognized character: " ~ inputRange.front.to!string, loc);
			}
			break;
		default: assert(false); /* generator's bug. */
		}
	}
	if(currentState != 0) throw new TokenizeError("Tokenizer is not terminated by " ~ inputRange.front.to!string, loc);
	tokenList ~= new Token(loc, EnumTokenType.__INPUT_END__);
	return tokenList;
}

auto reduceHooker_IDENTIFIER(Location loc, string text)
{
	switch(text)
	{
	case "package":
		return new Token(loc, EnumTokenType.PACKAGE, text);
	case "import":
		return new Token(loc, EnumTokenType.IMPORT, text);
	case "class":
		return new Token(loc, EnumTokenType.CLASS, text);
	case "trait":
		return new Token(loc, EnumTokenType.TRAIT, text);
	case "enum":
		return new Token(loc, EnumTokenType.ENUM, text);
	case "extends":
		return new Token(loc, EnumTokenType.EXTENDS, text);
	case "with":
		return new Token(loc, EnumTokenType.WITH, text);
	case "template":
		return new Token(loc, EnumTokenType.TEMPLATE, text);
	case "alias":
		return new Token(loc, EnumTokenType.ALIAS, text);
	case "using":
		return new Token(loc, EnumTokenType.USING, text);
	case "property":
		return new Token(loc, EnumTokenType.PROPERTY, text);
	case "function":
		return new Token(loc, EnumTokenType.FUNCTION, text);
	case "if":
		return new Token(loc, EnumTokenType.IF, text);
	case "else":
		return new Token(loc, EnumTokenType.ELSE, text);
	case "while":
		return new Token(loc, EnumTokenType.WHILE, text);
	case "do":
		return new Token(loc, EnumTokenType.DO, text);
	case "foreach":
		return new Token(loc, EnumTokenType.FOREACH, text);
	case "for":
		return new Token(loc, EnumTokenType.FOR, text);
	case "return":
		return new Token(loc, EnumTokenType.RETURN, text);
	case "break":
		return new Token(loc, EnumTokenType.BREAK, text);
	case "continue":
		return new Token(loc, EnumTokenType.CONTINUE, text);
	case "switch":
		return new Token(loc, EnumTokenType.SWITCH, text);
	case "case":
		return new Token(loc, EnumTokenType.CASE, text);
	case "default":
		return new Token(loc, EnumTokenType.DEFAULT, text);
	case "typeof":
		return new Token(loc, EnumTokenType.TYPEOF, text);
	case "this":
		return new Token(loc, EnumTokenType.THIS, text);
	case "super":
		return new Token(loc, EnumTokenType.SUPER, text);
	case "true":
		return new Token(loc, EnumTokenType.TRUE, text);
	case "false":
		return new Token(loc, EnumTokenType.FALSE, text);
	case "null":
		return new Token(loc, EnumTokenType.NULL, text);
	case "new":
		return new Token(loc, EnumTokenType.NEW, text);
	case "public":
		return new Token(loc, EnumTokenType.PUBLIC, text);
	case "private":
		return new Token(loc, EnumTokenType.PRIVATE, text);
	case "protected":
		return new Token(loc, EnumTokenType.PROTECTED, text);
	case "final":
		return new Token(loc, EnumTokenType.FINAL, text);
	case "const":
		return new Token(loc, EnumTokenType.CONST, text);
	case "static":
		return new Token(loc, EnumTokenType.STATIC, text);
	case "override":
		return new Token(loc, EnumTokenType.OVERRIDE, text);
	case "auto":
		return new Token(loc, EnumTokenType.AUTO, text);
	case "void":
		return new Token(loc, EnumTokenType.VOID, text);
	case "char":
		return new Token(loc, EnumTokenType.CHAR, text);
	case "uchar":
		return new Token(loc, EnumTokenType.UCHAR, text);
	case "byte":
		return new Token(loc, EnumTokenType.BYTE, text);
	case "short":
		return new Token(loc, EnumTokenType.SHORT, text);
	case "ushort":
		return new Token(loc, EnumTokenType.USHORT, text);
	case "int":
		return new Token(loc, EnumTokenType.INT, text);
	case "uint":
		return new Token(loc, EnumTokenType.UINT, text);
	case "long":
		return new Token(loc, EnumTokenType.LONG, text);
	case "ulong":
		return new Token(loc, EnumTokenType.ULONG, text);
	default:
		return new Token(loc, EnumTokenType.IDENTIFIER, text);
	}
}
