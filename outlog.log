Target tpeg ~master is up to date. Use --force to rebuild.
Running ./tpeg ml_grammar.tpeg -v
parsing input...
symbol finding...
ScriptNode
  packageName: com.cterm2.ml
  tokenizer: TokenizerNode
    moduleName: lexer
    skipPatterns #0: PatternNode
      patternString: " " / "\t" / "\r" / "\n"
    skipPatterns #1: PatternNode
      patternString: "//" (!"\n")* "\n"
    skipPatterns #2: PatternNode
      patternString: "/*" (!"*/")* "*/"
    patterns #0: PatternNode
      tokenName: INUMBER
      patternString: ("0"-"9")+
    patterns #1: PatternNode
      tokenName: HNUMBER
      patternString: "0x" ("0"-"9" / "A"-"F" / "a"-"f")+
    patterns #2: PatternNode
      tokenName: FNUMBER
      patternString: ("0"-"9")* "." ("0"-"9")+ ("F" / "f")
    patterns #3: PatternNode
      tokenName: DNUMBER
      patternString: ("0"-"9")* "." ("0"-"9")+ ("D" / "d")
    patterns #4: PatternNode
      tokenName: NUMBER
      patternString: ("0"-"9")* "." ("0"-"9")+
    patterns #5: PatternNode
      tokenName: STRING
      patternString: "\"" ("\\" ? / !"\"")* "\""
    patterns #6: PatternNode
      tokenName: CHARACTER
      patternString: "'" (!"'")* "'"
    patterns #7: PatternNode
      tokenName: IDENTIFIER
      patternString: ("A"-"Z" / "a"-"z" / "_") ("A"-"Z" / "a"-"z" / "0"-"9" / "_")*
    patterns #8: PatternNode
      tokenName: SEMICOLON
      patternString: ";"
    patterns #9: PatternNode
      tokenName: PERIOD
      patternString: "."
    patterns #10: PatternNode
      tokenName: COMMA
      patternString: ","
    patterns #11: PatternNode
      tokenName: COLON
      patternString: ":"
    patterns #12: PatternNode
      tokenName: RARROW
      patternString: "->"
    patterns #13: PatternNode
      tokenName: RARROW2
      patternString: "=>"
    patterns #14: PatternNode
      tokenName: LARROW
      patternString: "<-"
    patterns #15: PatternNode
      tokenName: SHARP
      patternString: "#"
    patterns #16: PatternNode
      tokenName: EQUAL
      patternString: "="
    patterns #17: PatternNode
      tokenName: PLUS_EQ
      patternString: "+="
    patterns #18: PatternNode
      tokenName: MINUS_EQ
      patternString: "-="
    patterns #19: PatternNode
      tokenName: ASTERISK_EQ
      patternString: "*="
    patterns #20: PatternNode
      tokenName: SLASH_EQ
      patternString: "/="
    patterns #21: PatternNode
      tokenName: PERCENT_EQ
      patternString: "%="
    patterns #22: PatternNode
      tokenName: AMPASAND_EQ
      patternString: "&="
    patterns #23: PatternNode
      tokenName: VL_EQ
      patternString: "|="
    patterns #24: PatternNode
      tokenName: CA_EQ
      patternString: "^="
    patterns #25: PatternNode
      tokenName: LAB2_EQ
      patternString: "<<="
    patterns #26: PatternNode
      tokenName: RAB2_EQ
      patternString: ">>="
    patterns #27: PatternNode
      tokenName: AMPASAND2
      patternString: "&&"
    patterns #28: PatternNode
      tokenName: VL2
      patternString: "||"
    patterns #29: PatternNode
      tokenName: CA2
      patternString: "^^"
    patterns #30: PatternNode
      tokenName: PLUS
      patternString: "+"
    patterns #31: PatternNode
      tokenName: MINUS
      patternString: "-"
    patterns #32: PatternNode
      tokenName: ASTERISK
      patternString: "*"
    patterns #33: PatternNode
      tokenName: SLASH
      patternString: "/"
    patterns #34: PatternNode
      tokenName: PERCENT
      patternString: "%"
    patterns #35: PatternNode
      tokenName: AMPASAND
      patternString: "&"
    patterns #36: PatternNode
      tokenName: VL
      patternString: "|"
    patterns #37: PatternNode
      tokenName: CA
      patternString: "^"
    patterns #38: PatternNode
      tokenName: LAB2
      patternString: "<<"
    patterns #39: PatternNode
      tokenName: RAB2
      patternString: ">>"
    patterns #40: PatternNode
      tokenName: LAB
      patternString: "<"
    patterns #41: PatternNode
      tokenName: RAB
      patternString: ">"
    patterns #42: PatternNode
      tokenName: LAB_EQ
      patternString: "<="
    patterns #43: PatternNode
      tokenName: RAB_EQ
      patternString: ">="
    patterns #44: PatternNode
      tokenName: EQ2
      patternString: "=="
    patterns #45: PatternNode
      tokenName: EX_EQ
      patternString: "!="
    patterns #46: PatternNode
      tokenName: QUESTION
      patternString: "?"
    patterns #47: PatternNode
      tokenName: PLUS2
      patternString: "++"
    patterns #48: PatternNode
      tokenName: MINUS2
      patternString: "--"
    patterns #49: PatternNode
      tokenName: ASTERISK2
      patternString: "**"
    patterns #50: PatternNode
      tokenName: PERIOD2
      patternString: ".."
    patterns #51: PatternNode
      tokenName: PERIOD3
      patternString: "..."
    patterns #52: PatternNode
      tokenName: LP
      patternString: "("
    patterns #53: PatternNode
      tokenName: RP
      patternString: ")"
    patterns #54: PatternNode
      tokenName: LB
      patternString: "{"
    patterns #55: PatternNode
      tokenName: RB
      patternString: "}"
    patterns #56: PatternNode
      tokenName: LBR
      patternString: "["
    patterns #57: PatternNode
      tokenName: RBR
      patternString: "]"
    Specialize Pattern for IDENTIFIER #0: PatternNode
      tokenName: PACKAGE
      patternString: "package"
    Specialize Pattern for IDENTIFIER #1: PatternNode
      tokenName: IMPORT
      patternString: "import"
    Specialize Pattern for IDENTIFIER #2: PatternNode
      tokenName: CLASS
      patternString: "class"
    Specialize Pattern for IDENTIFIER #3: PatternNode
      tokenName: TRAIT
      patternString: "trait"
    Specialize Pattern for IDENTIFIER #4: PatternNode
      tokenName: ENUM
      patternString: "enum"
    Specialize Pattern for IDENTIFIER #5: PatternNode
      tokenName: EXTENDS
      patternString: "extends"
    Specialize Pattern for IDENTIFIER #6: PatternNode
      tokenName: WITH
      patternString: "with"
    Specialize Pattern for IDENTIFIER #7: PatternNode
      tokenName: TEMPLATE
      patternString: "template"
    Specialize Pattern for IDENTIFIER #8: PatternNode
      tokenName: ALIAS
      patternString: "alias"
    Specialize Pattern for IDENTIFIER #9: PatternNode
      tokenName: USING
      patternString: "using"
    Specialize Pattern for IDENTIFIER #10: PatternNode
      tokenName: PROPERTY
      patternString: "property"
    Specialize Pattern for IDENTIFIER #11: PatternNode
      tokenName: FUNCTION
      patternString: "funcion"
    Specialize Pattern for IDENTIFIER #12: PatternNode
      tokenName: IF
      patternString: "if"
    Specialize Pattern for IDENTIFIER #13: PatternNode
      tokenName: ELSE
      patternString: "else"
    Specialize Pattern for IDENTIFIER #14: PatternNode
      tokenName: WHILE
      patternString: "while"
    Specialize Pattern for IDENTIFIER #15: PatternNode
      tokenName: DO
      patternString: "do"
    Specialize Pattern for IDENTIFIER #16: PatternNode
      tokenName: FOREACH
      patternString: "foreach"
    Specialize Pattern for IDENTIFIER #17: PatternNode
      tokenName: FOR
      patternString: "for"
    Specialize Pattern for IDENTIFIER #18: PatternNode
      tokenName: RETURN
      patternString: "return"
    Specialize Pattern for IDENTIFIER #19: PatternNode
      tokenName: BREAK
      patternString: "break"
    Specialize Pattern for IDENTIFIER #20: PatternNode
      tokenName: CONTINUE
      patternString: "continue"
    Specialize Pattern for IDENTIFIER #21: PatternNode
      tokenName: SWITCH
      patternString: "switch"
    Specialize Pattern for IDENTIFIER #22: PatternNode
      tokenName: CASE
      patternString: "case"
    Specialize Pattern for IDENTIFIER #23: PatternNode
      tokenName: DEFAULT
      patternString: "default"
    Specialize Pattern for IDENTIFIER #24: PatternNode
      tokenName: TYPEOF
      patternString: "typeof"
    Specialize Pattern for IDENTIFIER #25: PatternNode
      tokenName: THIS
      patternString: "this"
    Specialize Pattern for IDENTIFIER #26: PatternNode
      tokenName: SUPER
      patternString: "super"
    Specialize Pattern for IDENTIFIER #27: PatternNode
      tokenName: TRUE
      patternString: "true"
    Specialize Pattern for IDENTIFIER #28: PatternNode
      tokenName: FALSE
      patternString: "false"
    Specialize Pattern for IDENTIFIER #29: PatternNode
      tokenName: NULL
      patternString: "null"
    Specialize Pattern for IDENTIFIER #30: PatternNode
      tokenName: PUBLIC
      patternString: "public"
    Specialize Pattern for IDENTIFIER #31: PatternNode
      tokenName: PRIVATE
      patternString: "private"
    Specialize Pattern for IDENTIFIER #32: PatternNode
      tokenName: PROTECTED
      patternString: "protected"
    Specialize Pattern for IDENTIFIER #33: PatternNode
      tokenName: FINAL
      patternString: "final"
    Specialize Pattern for IDENTIFIER #34: PatternNode
      tokenName: CONST
      patternString: "const"
    Specialize Pattern for IDENTIFIER #35: PatternNode
      tokenName: STATIC
      patternString: "static"
    Specialize Pattern for IDENTIFIER #36: PatternNode
      tokenName: OVERRIDE
      patternString: "override"
    Specialize Pattern for IDENTIFIER #37: PatternNode
      tokenName: AUTO
      patternString: "auto"
    Specialize Pattern for IDENTIFIER #38: PatternNode
      tokenName: VOID
      patternString: "void"
    Specialize Pattern for IDENTIFIER #39: PatternNode
      tokenName: CHAR
      patternString: "char"
    Specialize Pattern for IDENTIFIER #40: PatternNode
      tokenName: UCHAR
      patternString: "uchar"
    Specialize Pattern for IDENTIFIER #41: PatternNode
      tokenName: BYTE
      patternString: "byte"
    Specialize Pattern for IDENTIFIER #42: PatternNode
      tokenName: SHORT
      patternString: "short"
    Specialize Pattern for IDENTIFIER #43: PatternNode
      tokenName: USHORT
      patternString: "ushort"
    Specialize Pattern for IDENTIFIER #44: PatternNode
      tokenName: INT
      patternString: "int"
    Specialize Pattern for IDENTIFIER #45: PatternNode
      tokenName: UINT
      patternString: "uint"
    Specialize Pattern for IDENTIFIER #46: PatternNode
      tokenName: LONG
      patternString: "long"
    Specialize Pattern for IDENTIFIER #47: PatternNode
      tokenName: ULONG
      patternString: "ulong"
  parser: ParserNode
    moduleName: parser
    headerPart: import com.cterm2.ml.syntaxTree;
import std.typecons, std.conv;
    startRuleName: compilation_unit
    rules #0: RuleNode
      ruleName: compilation_unit
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  Token[] pn; DeclarationNode[] ds; 
        nodes #1: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: package_def
              binderName: pd
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  pn = pd; 
        nodes #2: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: script_element
              binderName: se
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  ds ~= se; 
          isRequiredLeastOne: false
        nodes #3: PEGActionNode
          action_string:  return new ScriptNode(pn, ds); 
    rules #1: RuleNode
      ruleName: package_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: PACKAGE
          isBinded: false
          isRule: false
        nodes #1: PEGElementNode
          elementName: package_id
          binderName: pid
          isBinded: true
          isRule: true
        nodes #2: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #3: PEGActionNode
          action_string:  return pid; 
    rules #2: RuleNode
      ruleName: script_element
      typeName: DeclarationNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: import_decl
            binderName: id
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return id; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: partial_package_def
            binderName: ppd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ppd; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: class_def
            binderName: cd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return cd; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: trait_def
            binderName: td
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return td; 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: enum_def
            binderName: ed
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ed; 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: template_def
            binderName: tmd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return tmd; 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: alias_def
            binderName: ad
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ad; 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: class_body
            binderName: cb
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return cb; 
    rules #3: RuleNode
      ruleName: import_decl
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: IMPORT
          binderName: ft
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: import_list
          binderName: il
          isBinded: true
          isRule: true
        nodes #2: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #3: PEGActionNode
          action_string:  return new ImportDeclarationNode(ft.location, il); 
    rules #4: RuleNode
      ruleName: partial_package_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: PACKAGE
          binderName: ft
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: package_id
          binderName: pid
          isBinded: true
          isRule: true
        nodes #2: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: script_element
              binderName: e
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  return new PartialPackageDeclarationNode(ft.location, pid, [e]); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LB
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  DeclarationNode[] elms; 
            nodes #2: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: script_element
                  binderName: se
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string:  elms ~= se; 
              isRequiredLeastOne: false
            nodes #3: PEGElementNode
              elementName: RB
              isBinded: false
              isRule: false
            nodes #4: PEGActionNode
              action_string:  return new PartialPackageDeclarationNode(ft.location, pid, elms); 
    rules #5: RuleNode
      ruleName: class_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); TypeNode ef; TypeNode[] wts; 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: class_qualifier
              binderName: cq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(cq); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: CLASS
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #4: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: EXTENDS
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: t
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  ef = t; 
        nodes #5: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: WITH
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: wt
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  wts ~= wt; 
          isRequiredLeastOne: false
        nodes #6: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return new ClassDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id, ef, wts, null); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LB
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  DeclarationNode[] dns; 
            nodes #2: PEGLoopQualifiedNode
              inner: PEGSwitchingNode
                nodes #0: PEGSequentialNode
                  nodes #0: PEGElementNode
                    elementName: import_decl
                    binderName: idl
                    isBinded: true
                    isRule: true
                  nodes #1: PEGActionNode
                    action_string:  dns ~= idl; 
                nodes #1: PEGSequentialNode
                  nodes #0: PEGElementNode
                    elementName: class_body
                    binderName: cb
                    isBinded: true
                    isRule: true
                  nodes #1: PEGActionNode
                    action_string:  dns ~= cb; 
              isRequiredLeastOne: false
            nodes #3: PEGElementNode
              elementName: RB
              isBinded: false
              isRule: false
            nodes #4: PEGActionNode
              action_string:  return new ClassDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id, ef, wts, dns); 
    rules #6: RuleNode
      ruleName: class_body
      typeName: DeclarationNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: field_def
            binderName: fd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fd; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: method_def
            binderName: md
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return md; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: property_def
            binderName: pd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return pd; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ctor_def
            binderName: cd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return cd; 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: alias_def
            binderName: ad
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ad; 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return new StaticInitializerNode(st); 
    rules #7: RuleNode
      ruleName: trait_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); TypeNode[] wts; 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: trait_qualifier
              binderName: tq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(tq); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: TRAIT
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #4: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: WITH
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: t
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  wts ~= t; 
          isRequiredLeastOne: false
        nodes #5: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return new TraitDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id, wts, null); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LB
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  DeclarationNode[] dns; 
            nodes #2: PEGLoopQualifiedNode
              inner: PEGSwitchingNode
                nodes #0: PEGSequentialNode
                  nodes #0: PEGElementNode
                    elementName: import_decl
                    binderName: idl
                    isBinded: true
                    isRule: true
                  nodes #1: PEGActionNode
                    action_string:  dns ~= idl; 
                nodes #1: PEGSequentialNode
                  nodes #0: PEGElementNode
                    elementName: trait_body
                    binderName: tb
                    isBinded: true
                    isRule: true
                  nodes #1: PEGActionNode
                    action_string:  dns ~= tb; 
              isRequiredLeastOne: false
            nodes #3: PEGElementNode
              elementName: RB
              isBinded: false
              isRule: false
            nodes #4: PEGActionNode
              action_string:  return new TraitDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id, wts, dns); 
    rules #8: RuleNode
      ruleName: trait_body
      typeName: DeclarationNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: method_def
            binderName: md
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return md; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: property_def
            binderName: pd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return pd; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ctor_def
            binderName: cd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return cd; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: alias_def
            binderName: ad
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ad; 
    rules #9: RuleNode
      ruleName: enum_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: enum_qualifier
              binderName: eq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(eq); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: ENUM
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGElementNode
          elementName: IDENTIFIER
          binderName: id
          isBinded: true
          isRule: false
        nodes #4: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return new EnumDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id.text, null, null); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LB
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  DeclarationNode[] nodes; EnumElementNode[] bodies; 
            nodes #2: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: import_decl
                  binderName: idl
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string:  nodes ~= idl; 
              isRequiredLeastOne: false
            nodes #3: PEGSkippableNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: enum_body
                  binderName: eb
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string:  bodies = eb; 
            nodes #4: PEGLoopQualifiedNode
              inner: PEGSwitchingNode
                nodes #0: PEGSequentialNode
                  nodes #0: PEGElementNode
                    elementName: import_decl
                    binderName: idl2
                    isBinded: true
                    isRule: true
                  nodes #1: PEGActionNode
                    action_string:  nodes ~= idl2; 
                nodes #1: PEGSequentialNode
                  nodes #0: PEGElementNode
                    elementName: class_body
                    binderName: cb
                    isBinded: true
                    isRule: true
                  nodes #1: PEGActionNode
                    action_string:  nodes ~= cb; 
              isRequiredLeastOne: false
            nodes #5: PEGElementNode
              elementName: RB
              isBinded: false
              isRule: false
            nodes #6: PEGActionNode
              action_string:  return new EnumDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id.text, bodies, nodes); 
    rules #10: RuleNode
      ruleName: enum_body
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  EnumElementNode[] eens; 
        nodes #1: PEGElementNode
          elementName: enum_element
          binderName: ee
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  eens ~= ee; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: enum_element
              binderName: ee2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  eens ~= ee2; 
          isRequiredLeastOne: false
        nodes #4: PEGSkippableNode
          inner: PEGSwitchingNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
        nodes #5: PEGActionNode
          action_string:  return eens; 
    rules #11: RuleNode
      ruleName: enum_element
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  ExpressionNode[] els; 
        nodes #1: PEGElementNode
          elementName: IDENTIFIER
          binderName: id
          isBinded: true
          isRule: false
        nodes #2: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LP
              isBinded: false
              isRule: false
            nodes #1: PEGSkippableNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: expression_list
                  binderName: el
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string:  els = el; 
            nodes #2: PEGElementNode
              elementName: RP
              isBinded: false
              isRule: false
        nodes #3: PEGActionNode
          action_string:  return new EnumElementNode(id.location, id.text, els); 
    rules #12: RuleNode
      ruleName: template_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TemplateVirtualParamNode[] template_vps = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: template_qualifier
              binderName: tq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(tq); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: TEMPLATE
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGElementNode
          elementName: IDENTIFIER
          binderName: id
          isBinded: true
          isRule: false
        nodes #4: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #5: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: template_arg_list
              binderName: tvps
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  template_vps = tvps; 
        nodes #6: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #7: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return new TemplateDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id.text, template_vps, null); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: template_body
              binderName: tb
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  return new TemplateDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id.text, template_vps, [tb]); 
          nodes #2: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LB
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  DeclarationNode[] child; 
            nodes #2: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: template_body
                  binderName: tb
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string:  child ~= tb; 
              isRequiredLeastOne: false
            nodes #3: PEGElementNode
              elementName: RB
              isBinded: false
              isRule: false
            nodes #4: PEGActionNode
              action_string:  return new TemplateDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, id.text, template_vps, child); 
    rules #13: RuleNode
      ruleName: template_body
      typeName: DeclarationNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: import_decl
            binderName: id
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return id; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: class_def
            binderName: cd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return cd; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: trait_def
            binderName: td
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return td; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: enum_def
            binderName: ed
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ed; 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: template_def
            binderName: tmd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return tmd; 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: alias_def
            binderName: ad
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ad; 
    rules #14: RuleNode
      ruleName: alias_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  DefinitionIdentifierNode id; TypeNode t; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: alias_qualifier
              binderName: aq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(aq); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: USING
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: def_id
              binderName: did
              isBinded: true
              isRule: true
            nodes #1: PEGElementNode
              elementName: EQUAL
              isBinded: false
              isRule: false
            nodes #2: PEGElementNode
              elementName: type
              binderName: tt
              isBinded: true
              isRule: true
            nodes #3: PEGActionNode
              action_string:  id = did; t = tt; 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: type
              binderName: tt
              isBinded: true
              isRule: true
            nodes #1: PEGElementNode
              elementName: def_id
              binderName: did
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  id = did; t = tt; 
        nodes #4: PEGActionNode
          action_string:  return new AliasDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, t, id); 
    rules #15: RuleNode
      ruleName: field_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNode t = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: field_qualifier
                  binderName: fq
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string:  q = q.combine(fq); 
              isRequiredLeastOne: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: tp
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  t = tp; 
          nodes #1: PEGLoopQualifiedNode
            inner: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: field_qualifier
                binderName: fq
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string:  q = q.combine(fq); 
            isRequiredLeastOne: true
        nodes #2: PEGElementNode
          elementName: field_def_list
          binderName: fdl
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #4: PEGActionNode
          action_string:  return new FieldDeclarationNode(q.location.line == int.max ? t.location : q.location, q, t, fdl); 
    rules #16: RuleNode
      ruleName: field_def_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  NameValuePair[] nvplist; 
        nodes #1: PEGElementNode
          elementName: nvpair
          binderName: nvp
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  nvplist ~= nvp; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: nvpair
              binderName: nvp2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  nvplist ~= nvp2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return nvplist; 
    rules #17: RuleNode
      ruleName: nvpair
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return new NameValuePair(id.location, id.text, e); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new NameValuePair(id.location, id.text, null); 
    rules #18: RuleNode
      ruleName: method_def
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: function_def
            binderName: fd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fd; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: procedure_def
            binderName: pd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return pd; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: abstract_method_def
            binderName: amd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return amd; 
    rules #19: RuleNode
      ruleName: procedure_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNode t = null; VirtualParamNode[] vps = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: method_qualifier
                  binderName: mq
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string: q = q.combine(mq);
              isRequiredLeastOne: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: tt
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  t = tt; 
          nodes #1: PEGLoopQualifiedNode
            inner: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: method_qualifier
                binderName: mq
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string: q = q.combine(mq);
            isRequiredLeastOne: true
        nodes #2: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #4: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: varg_list
              binderName: vpl
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  vps = vpl; 
        nodes #5: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #6: PEGElementNode
          elementName: statement
          binderName: st
          isBinded: true
          isRule: true
        nodes #7: PEGActionNode
          action_string:  return new MethodDeclarationNode(q.location.line == int.max ? t.location : q.location, q, t, id, vps, st); 
    rules #20: RuleNode
      ruleName: function_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNode t = null; VirtualParamNode[] vps = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: method_qualifier
                  binderName: mq
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string: q = q.combine(mq);
              isRequiredLeastOne: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: tt
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  t = tt; 
          nodes #1: PEGLoopQualifiedNode
            inner: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: method_qualifier
                binderName: mq
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string: q = q.combine(mq);
            isRequiredLeastOne: true
        nodes #2: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #4: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: varg_list
              binderName: vpl
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  vps = vpl; 
        nodes #5: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #6: PEGElementNode
          elementName: EQUAL
          isBinded: false
          isRule: false
        nodes #7: PEGElementNode
          elementName: expression
          binderName: e
          isBinded: true
          isRule: true
        nodes #8: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #9: PEGActionNode
          action_string:  return new MethodDeclarationNode(q.location.line == int.max ? t.location : q.location, q, t, id, vps, e); 
    rules #21: RuleNode
      ruleName: abstract_method_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNode t = null; VirtualParamNode[] vps = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGLoopQualifiedNode
              inner: PEGSequentialNode
                nodes #0: PEGElementNode
                  elementName: method_qualifier
                  binderName: mq
                  isBinded: true
                  isRule: true
                nodes #1: PEGActionNode
                  action_string: q = q.combine(mq);
              isRequiredLeastOne: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: tt
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  t = tt; 
          nodes #1: PEGLoopQualifiedNode
            inner: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: method_qualifier
                binderName: mq
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string: q = q.combine(mq);
            isRequiredLeastOne: true
        nodes #2: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #4: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: varg_list
              binderName: vpl
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  vps = vpl; 
        nodes #5: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #6: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #7: PEGActionNode
          action_string:  return new MethodDeclarationNode(q.location.line == int.max ? t.location : q.location, q, t, id, vps); 
    rules #22: RuleNode
      ruleName: property_def
      typeName: DeclarationNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: getter_def
            binderName: gd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return gd; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: setter_def
            binderName: sd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return sd; 
    rules #23: RuleNode
      ruleName: setter_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNode tp = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: method_qualifier
              binderName: q2
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(q2); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: PROPERTY
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: type
              binderName: t
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  tp = t; 
        nodes #4: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #5: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #6: PEGElementNode
          elementName: tn_pair
          binderName: p
          isBinded: true
          isRule: true
        nodes #7: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #8: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: statement
              binderName: st
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  return new SetterDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, tp, id, p, st); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return new SetterDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, tp, id, p, null); 
    rules #24: RuleNode
      ruleName: getter_def
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNode tp = null; auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: method_qualifier
              binderName: q2
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(q2); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: PROPERTY
          binderName: ft
          isBinded: true
          isRule: false
        nodes #3: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: type
              binderName: t
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  tp = t; 
        nodes #4: PEGElementNode
          elementName: def_id
          binderName: id
          isBinded: true
          isRule: true
        nodes #5: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: LP
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: RP
              isBinded: false
              isRule: false
        nodes #6: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: EQUAL
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: expression
              binderName: e
              isBinded: true
              isRule: true
            nodes #2: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #3: PEGActionNode
              action_string:  return new GetterDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, tp, id, e); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: SEMICOLON
              isBinded: false
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return new GetterDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, tp, id, null); 
          nodes #2: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: statement
              binderName: st
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  return new GetterDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, tp, id, st); 
    rules #25: RuleNode
      ruleName: ctor_def
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: full_ctor_def
            binderName: fcd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fcd; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: abs_ctor_def
            binderName: acd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return acd; 
    rules #26: RuleNode
      ruleName: ctor_quals
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  auto q = Qualifier(Location(int.max, int.max), Qualifiers.Private); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: ctor_qualifier
              binderName: cq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(cq); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return q; 
    rules #27: RuleNode
      ruleName: full_ctor_def
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ctor_quals
            binderName: q
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: THIS
            binderName: ft
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: varg_list
            binderName: vl
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #6: PEGActionNode
            action_string:  return new ConstructorDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, vl, st); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ctor_quals
            binderName: q
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: THIS
            binderName: ft
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #5: PEGActionNode
            action_string:  return new ConstructorDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, null, st); 
    rules #28: RuleNode
      ruleName: abs_ctor_def
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ctor_quals
            binderName: q
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: THIS
            binderName: ft
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: varg_list
            binderName: vl
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #6: PEGActionNode
            action_string:  return new ConstructorDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, vl, null); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ctor_quals
            binderName: q
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: THIS
            binderName: ft
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #5: PEGActionNode
            action_string:  return new ConstructorDeclarationNode(q.location.line == int.max ? ft.location : q.location, q, null, null); 
    rules #29: RuleNode
      ruleName: tn_pair
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new TypeNamePair(t.location, t, id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new TypeNamePair(id.location, null, id.text); 
    rules #30: RuleNode
      ruleName: tn_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TypeNamePair[] tnps; 
        nodes #1: PEGElementNode
          elementName: tn_pair
          binderName: tnp
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  tnps ~= tnp; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: tn_pair
              binderName: tnp2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  tnps ~= tnp2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return tnps; 
    rules #31: RuleNode
      ruleName: statement
      typeName: StatementNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: if_stmt
            binderName: ifs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ifs; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: while_stmt
            binderName: ws
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ws; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: do_stmt
            binderName: ds
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ds; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: foreach_stmt
            binderName: fes
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fes; 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: for_stmt
            binderName: fs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fs; 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: return_stmt
            binderName: rs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return rs; 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: break_stmt
            binderName: bs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return bs; 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: continue_stmt
            binderName: cs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return cs; 
        nodes #8: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: switch_stmt
            binderName: ss
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ss; 
        nodes #9: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: block_stmt
            binderName: bls
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return bls; 
        nodes #10: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return e; 
        nodes #11: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return null; 
    rules #32: RuleNode
      ruleName: if_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IF
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: c
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: statement
            binderName: t
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: ELSE
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: n
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new ConditionalNode(ft.location, c, t, n); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IF
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: c
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: statement
            binderName: t
            isBinded: true
            isRule: true
          nodes #5: PEGActionNode
            action_string:  return new ConditionalNode(ft.location, c, t, null); 
    rules #33: RuleNode
      ruleName: while_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: WHILE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #3: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new PreConditionLoopNode(ft.location, id.text, e, st); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: WHILE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #5: PEGActionNode
            action_string:  return new PreConditionLoopNode(ft.location, e, st); 
    rules #34: RuleNode
      ruleName: do_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: DO
            binderName: ft
            isBinded: true
            isRule: false
          nodes #3: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: WHILE
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: expression
            binderName: c
            isBinded: true
            isRule: true
          nodes #7: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #8: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #9: PEGActionNode
            action_string:  return new PostConditionLoopNode(ft.location, id.text, c, st); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: DO
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: WHILE
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: expression
            binderName: c
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #7: PEGActionNode
            action_string:  return new PostConditionLoopNode(ft.location, c, st); 
    rules #35: RuleNode
      ruleName: foreach_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: foreach_stmt_impl
            binderName: fs
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return fs.withName(id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: foreach_stmt_impl
            binderName: fs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fs; 
    rules #36: RuleNode
      ruleName: foreach_stmt_impl
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: FOREACH
          binderName: ft
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #2: PEGElementNode
          elementName: tn_list
          binderName: tnl
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: LARROW
          isBinded: false
          isRule: false
        nodes #4: PEGElementNode
          elementName: expression
          binderName: e
          isBinded: true
          isRule: true
        nodes #5: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #6: PEGElementNode
          elementName: statement
          binderName: st
          isBinded: true
          isRule: true
        nodes #7: PEGActionNode
          action_string:  return new ForeachStatementNode(ft.location, tnl, e, st); 
    rules #37: RuleNode
      ruleName: for_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: for_stmt_impl
            binderName: fs
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return fs.withName(id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: for_stmt_impl
            binderName: fs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fs; 
    rules #38: RuleNode
      ruleName: for_stmt_impl
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: expression
            binderName: e2
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: expression
            binderName: e3
            isBinded: true
            isRule: true
          nodes #7: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #8: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #9: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, e, e2, e3, st); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: expression
            binderName: e2
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #7: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #8: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, e, e2, null, st); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: expression
            binderName: e3
            isBinded: true
            isRule: true
          nodes #6: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #7: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #8: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, e, null, e3, st); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, e, null, null, st); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: e2
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: expression
            binderName: e3
            isBinded: true
            isRule: true
          nodes #6: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #7: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #8: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, null, e2, e3, st); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: e2
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, null, e2, null, st); 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: expression
            binderName: e3
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, null, null, e3, st); 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FOR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new ForStatementNode(ft.location, null, null, null, st); 
    rules #39: RuleNode
      ruleName: return_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: RETURN
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new ReturnNode(ft.location, e); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: RETURN
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new ReturnNode(ft.location, null); 
    rules #40: RuleNode
      ruleName: break_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: BREAK
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new BreakLoopNode(ft.location, id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: BREAK
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new BreakLoopNode(ft.location, null); 
    rules #41: RuleNode
      ruleName: continue_stmt
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CONTINUE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new ContinueLoopNode(ft.location, id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CONTINUE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: SEMICOLON
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new ContinueLoopNode(ft.location, null); 
    rules #42: RuleNode
      ruleName: switch_stmt
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: SWITCH
          binderName: ft
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #2: PEGElementNode
          elementName: expression
          binderName: te
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: RP
          isBinded: false
          isRule: false
        nodes #4: PEGElementNode
          elementName: LB
          isBinded: false
          isRule: false
        nodes #5: PEGActionNode
          action_string:  SwitchSectionNode[] sects; 
        nodes #6: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: case_stmt
                binderName: cs
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string:  sects ~= cs; 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: default_stmt
                binderName: ds
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string:  sects ~= ds; 
          isRequiredLeastOne: false
        nodes #7: PEGElementNode
          elementName: RB
          isBinded: false
          isRule: false
        nodes #8: PEGActionNode
          action_string:  return new SwitchStatementNode(ft.location, te, sects); 
    rules #43: RuleNode
      ruleName: case_stmt
      typeName: SwitchSectionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: value_case_sect
            binderName: vcs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return vcs; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type_case_sect
            binderName: tcs
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return tcs; 
    rules #44: RuleNode
      ruleName: value_case_sect
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: CASE
          binderName: ft
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: expression_list
          binderName: el
          isBinded: true
          isRule: true
        nodes #2: PEGElementNode
          elementName: RARROW2
          isBinded: false
          isRule: false
        nodes #3: PEGElementNode
          elementName: statement
          binderName: st
          isBinded: true
          isRule: true
        nodes #4: PEGActionNode
          action_string:  return new ValueCaseSectionNode(ft.location, el, st); 
    rules #45: RuleNode
      ruleName: type_case_sect
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CASE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: CONST
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: def_id
            binderName: id
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: IF
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #7: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #8: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #9: PEGActionNode
            action_string:  return new TypeCaseSectionNode(ft.location, true, id, t, e, st); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CASE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: CONST
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: def_id
            binderName: id
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #5: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #6: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #7: PEGActionNode
            action_string:  return new TypeCaseSectionNode(ft.location, true, id, t, null, st); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CASE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: def_id
            binderName: id
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: IF
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #6: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #7: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #8: PEGActionNode
            action_string:  return new TypeCaseSectionNode(ft.location, false, id, t, e, st); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CASE
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: def_id
            binderName: id
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: COLON
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #5: PEGElementNode
            elementName: statement
            binderName: st
            isBinded: true
            isRule: true
          nodes #6: PEGActionNode
            action_string:  return new TypeCaseSectionNode(ft.location, false, id, t, null, st); 
    rules #46: RuleNode
      ruleName: default_stmt
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: DEFAULT
          binderName: ft
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: RARROW2
          isBinded: false
          isRule: false
        nodes #2: PEGElementNode
          elementName: statement
          binderName: s
          isBinded: true
          isRule: true
        nodes #3: PEGActionNode
          action_string:  return new DefaultSectionNode(ft.location, s); 
    rules #47: RuleNode
      ruleName: block_stmt
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: LBR
          binderName: t
          isBinded: true
          isRule: false
        nodes #1: PEGActionNode
          action_string:  StatementNode[] stmts; 
        nodes #2: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: localvar_def
                binderName: lvd
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string:  stmts ~= lvd; 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: statement
                binderName: st
                isBinded: true
                isRule: true
              nodes #1: PEGActionNode
                action_string:  stmts ~= st; 
          isRequiredLeastOne: false
        nodes #3: PEGElementNode
          elementName: RBR
          isBinded: false
          isRule: false
        nodes #4: PEGActionNode
          action_string:  return new BlockStatementNode(t.location, stmts); 
    rules #48: RuleNode
      ruleName: localvar_def
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: full_lvd
            binderName: flvd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return flvd; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: inferenced_lvd
            binderName: ilvd
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ilvd; 
    rules #49: RuleNode
      ruleName: nvp_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  NameValuePair[] nvps; 
        nodes #1: PEGElementNode
          elementName: nvpair
          binderName: nvp
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  nvps ~= nvp; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: nvpair
              binderName: nvp2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  nvps ~= nvp2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return nvps; 
    rules #50: RuleNode
      ruleName: full_lvd
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  auto q = Qualifier(Location(int.max, int.max), Qualifiers.Public); 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: lvar_qualifier
              binderName: lq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(lq); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: type
          binderName: tp
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: nvp_list
          binderName: nvps
          isBinded: true
          isRule: true
        nodes #4: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #5: PEGActionNode
          action_string:  return new LocalVariableDeclarationNode(q.location.line == int.max ? tp.location : q.location, q, tp, nvps); 
    rules #51: RuleNode
      ruleName: inferenced_lvd
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: lvar_qualifier
          binderName: q
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: lvar_qualifier
              binderName: q2
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  q = q.combine(q2); 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: nvp_list
          binderName: nvps
          isBinded: true
          isRule: true
        nodes #3: PEGElementNode
          elementName: SEMICOLON
          isBinded: false
          isRule: false
        nodes #4: PEGActionNode
          action_string:  return new LocalVariableDeclarationNode(q.location, q, new InferenceTypeNode(q.location), nvps); 
    rules #52: RuleNode
      ruleName: expression_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  ExpressionNode[] elist; 
        nodes #1: PEGElementNode
          elementName: expression
          binderName: e
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  elist ~= e; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: expression
              binderName: e2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  elist ~= e2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return elist; 
    rules #53: RuleNode
      ruleName: expression
      typeName: ExpressionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: postfix_expr
            binderName: l
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: r
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return new AssignOperatorNode(l, r); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: postfix_expr
            binderName: l
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: assign_ops
            binderName: o
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: expression
            binderName: r
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return new OperatedAssignNode(l, o, r); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: alternate_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return e; 
    rules #54: RuleNode
      ruleName: assign_ops
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PLUS_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Add; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: MINUS_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Sub; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ASTERISK_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Mul; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SLASH_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Div; 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PERCENT_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Mod; 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: AMPASAND_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.And; 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: VL_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Or; 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CA_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.Xor; 
        nodes #8: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LAB2_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.LeftShift; 
        nodes #9: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: RAB2_EQ
            isBinded: false
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return BinaryOperatorType.RightShift; 
    rules #55: RuleNode
      ruleName: alternate_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: short_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: QUESTION
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: short_expr
              binderName: t
              isBinded: true
              isRule: true
            nodes #2: PEGElementNode
              elementName: COLON
              isBinded: false
              isRule: false
            nodes #3: PEGElementNode
              elementName: short_expr
              binderName: n
              isBinded: true
              isRule: true
            nodes #4: PEGActionNode
              action_string:  e = new AlternateValueNode(e, t, n); 
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #56: RuleNode
      ruleName: short_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: comp_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: AMPASAND2
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: comp_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.LogAnd, e2); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: VL2
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: comp_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.LogOr, e2); 
            nodes #2: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: CA2
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: comp_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.LogXor, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #57: RuleNode
      ruleName: comp_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: shift_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LAB
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: shift_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Less, e2); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: RAB
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: shift_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Greater, e2); 
            nodes #2: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: EQ2
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: shift_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Equiv, e2); 
            nodes #3: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: EX_EQ
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: shift_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Inequiv, e2); 
            nodes #4: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LAB_EQ
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: shift_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.LessEq, e2); 
            nodes #5: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: RAB_EQ
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: shift_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.GreaterEq, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #58: RuleNode
      ruleName: shift_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: bit_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LAB2
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: bit_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.LeftShift, e2); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: RAB2
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: bit_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.RightShift, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #59: RuleNode
      ruleName: bit_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: a1_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: AMPASAND
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: a1_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.And, e2); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: VL
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: a1_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Or, e2); 
            nodes #2: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: CA
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: a1_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Xor, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #60: RuleNode
      ruleName: a1_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: a2_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PLUS
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: a2_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Add, e2); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: MINUS
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: a2_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Sub, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #61: RuleNode
      ruleName: a2_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: range_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: ASTERISK
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: range_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Mul, e2); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: SLASH
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: range_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Div, e2); 
            nodes #2: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PERCENT
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: range_expr
                binderName: e2
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Mod, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #62: RuleNode
      ruleName: range_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: prefix_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: PERIOD2
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: prefix_expr
              binderName: e2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  e = new BinaryOperatorNode(e, BinaryOperatorType.Ranged, e2); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #63: RuleNode
      ruleName: prefix_expr
      typeName: ExpressionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PLUS
            isBinded: false
            isRule: false
          nodes #1: PEGElementNode
            elementName: prefix_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return e; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: MINUS
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: prefix_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return new PreOperatorNode(t.location, e, UnaryOperatorType.Negate); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PLUS2
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: prefix_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return new PreOperatorNode(t.location, e, UnaryOperatorType.Increase); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: MINUS2
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: prefix_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return new PreOperatorNode(t.location, e, UnaryOperatorType.Decrease); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ASTERISK2
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: prefix_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return new PreOperatorNode(t.location, e, UnaryOperatorType.Square); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: postfix_expr
            binderName: e
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return e; 
    rules #64: RuleNode
      ruleName: postfix_expr
      typeName: ExpressionNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: primary_expr
          binderName: e
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PLUS2
                isBinded: false
                isRule: false
              nodes #1: PEGActionNode
                action_string:  e = new PostOperatorNode(e, UnaryOperatorType.Increase); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: MINUS2
                isBinded: false
                isRule: false
              nodes #1: PEGActionNode
                action_string:  e = new PostOperatorNode(e, UnaryOperatorType.Decrease); 
            nodes #2: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: ASTERISK2
                isBinded: false
                isRule: false
              nodes #1: PEGActionNode
                action_string:  e = new PostOperatorNode(e, UnaryOperatorType.Square); 
            nodes #3: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LBR
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: expression
                binderName: d
                isBinded: true
                isRule: true
              nodes #2: PEGElementNode
                elementName: RBR
                isBinded: false
                isRule: false
              nodes #3: PEGActionNode
                action_string:  e = new ArrayRefNode(e, [d]); 
            nodes #4: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LBR
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: RBR
                isBinded: false
                isRule: false
              nodes #2: PEGActionNode
                action_string:  e = new ArrayRefNode(e, null); 
            nodes #5: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LP
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: expression_list
                binderName: ps
                isBinded: true
                isRule: true
              nodes #2: PEGElementNode
                elementName: RP
                isBinded: false
                isRule: false
              nodes #3: PEGActionNode
                action_string:  e = new FuncallNode(e, ps); 
            nodes #6: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LP
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: RP
                isBinded: false
                isRule: false
              nodes #2: PEGActionNode
                action_string:  e = new FuncallNode(e, null); 
            nodes #7: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PERIOD
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: IDENTIFIER
                binderName: id
                isBinded: true
                isRule: false
              nodes #2: PEGElementNode
                elementName: template_tail
                binderName: tt
                isBinded: true
                isRule: true
              nodes #3: PEGActionNode
                action_string:  e = new ObjectRefNode(e, new TemplateInstantiateNode(id.location, id.text, tt)); 
            nodes #8: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PERIOD
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: IDENTIFIER
                binderName: id
                isBinded: true
                isRule: false
              nodes #2: PEGActionNode
                action_string:  e = new ObjectRefNode(e, new IdentifierReferenceNode(id.location, id.text)); 
            nodes #9: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: RARROW
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: single_types
                binderName: st
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  e = new CastingNode(e, st); 
            nodes #10: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: RARROW
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: LP
                isBinded: false
                isRule: false
              nodes #2: PEGElementNode
                elementName: restricted_type
                binderName: rt
                isBinded: true
                isRule: true
              nodes #3: PEGElementNode
                elementName: RP
                isBinded: false
                isRule: false
              nodes #4: PEGActionNode
                action_string:  e = new CastingNode(e, rt); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return e; 
    rules #65: RuleNode
      ruleName: primary_expr
      typeName: ExpressionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: literals
            binderName: l
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return l; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: special_literals
            binderName: sl
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return sl; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: lambda_expr
            binderName: le
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return le; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #1: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return e; 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: template_tail
            binderName: tt
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return new TemplateInstantiateNode(id.location, id.text, tt); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new IdentifierReferenceNode(id.location, id.text); 
    rules #66: RuleNode
      ruleName: literals
      typeName: ExpressionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: INUMBER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new IntLiteralNode(t.location, t.text.to!int); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: HNUMBER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new IntLiteralNode(t.location, t.text.to!int(16)); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FNUMBER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new FloatLiteralNode(t.location, t.text.to!float); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: DNUMBER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new DoubleLiteralNode(t.location, t.text.to!double); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: NUMBER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new NumericLiteralNode(t.location, t.text.to!real); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STRING
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new StringLiteralNode(t.location, t.text); 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CHARACTER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new CharacterLiteralNode(t.location, t.text[0]); 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: function_literal
            binderName: fl
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return fl; 
        nodes #8: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: array_literal
            binderName: al
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return al; 
    rules #67: RuleNode
      ruleName: function_literal
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FUNCTION
            binderName: f
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: literal_varg_list
            binderName: vl
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: block_stmt
            binderName: bs
            isBinded: true
            isRule: true
          nodes #5: PEGActionNode
            action_string:  return new FunctionLiteralNode(f.location, vl, bs); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FUNCTION
            binderName: f
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: block_stmt
            binderName: bs
            isBinded: true
            isRule: true
          nodes #4: PEGActionNode
            action_string:  return new FunctionLiteralNode(f.location, null, bs); 
    rules #68: RuleNode
      ruleName: array_literal
      typeName: ExpressionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LBR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: expression_list
            binderName: el
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: RBR
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new ArrayLiteralNode(ft.location, el); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LBR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: assoc_array_element_list
            binderName: el
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: RBR
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new AssocArrayLiteralNode(ft.location, el); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LBR
            binderName: ft
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: RBR
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new ArrayLiteralNode(ft.location, null); 
    rules #69: RuleNode
      ruleName: special_literals
      typeName: ExpressionNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: THIS
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new ThisReferenceNode(t.location); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SUPER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new SuperReferenceNode(t.location); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: TRUE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new BooleanLiteralNode(t.location, true); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FALSE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new BooleanLiteralNode(t.location, false); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: NULL
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new NullLiteralNode(t.location); 
    rules #70: RuleNode
      ruleName: lambda_expr
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LP
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: literal_varg_list
            binderName: ps
            isBinded: true
            isRule: true
          nodes #2: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #4: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #5: PEGActionNode
            action_string:  return new FunctionLiteralNode(t.location, ps, e); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LP
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #4: PEGActionNode
            action_string:  return new FunctionLiteralNode(t.location, null, e); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: literal_varg
            binderName: vp
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: RARROW2
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return new FunctionLiteralNode(vp, e); 
    rules #71: RuleNode
      ruleName: template_arg_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  TemplateVirtualParamNode[] params; 
        nodes #1: PEGElementNode
          elementName: template_arg
          binderName: p
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  params ~= p; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: template_arg
              binderName: p2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  params ~= p2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return params; 
    rules #72: RuleNode
      ruleName: template_arg
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: template_arg_head
          binderName: head
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: EQUAL
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: type
              binderName: t
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  head = new TemplateVirtualParamNode(head, t); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return head; 
    rules #73: RuleNode
      ruleName: template_arg_type
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  alias ReturnType = Tuple!(TemplateVirtualParamNode.ParamType, "type", TypeNode, "stype", Location, "location"); 
        nodes #1: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: type
              binderName: t
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  return ReturnType(TemplateVirtualParamNode.ParamType.Type, t, t.location); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: CLASS
              binderName: tk
              isBinded: true
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return ReturnType(TemplateVirtualParamNode.ParamType.Class, null, tk.location); 
          nodes #2: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: ALIAS
              binderName: tk
              isBinded: true
              isRule: false
            nodes #1: PEGActionNode
              action_string:  return ReturnType(TemplateVirtualParamNode.ParamType.SymbolAlias, null, tk.location); 
    rules #74: RuleNode
      ruleName: template_arg_head
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: template_arg_type
            binderName: type
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new TemplateVirtualParamNode(type.location, type.type, type.stype, id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new TemplateVirtualParamNode(id.location, TemplateVirtualParamNode.ParamType.Any, null, id.text); 
    rules #75: RuleNode
      ruleName: varg_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  VirtualParamNode params[]; 
        nodes #1: PEGElementNode
          elementName: varg
          binderName: t
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  params ~= t; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: varg
              binderName: v
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  params ~= v; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return params; 
    rules #76: RuleNode
      ruleName: varg
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: n
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: dv
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #5: PEGActionNode
            action_string:  return new VirtualParamNode(t, n.text, dv, true); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: n
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: dv
            isBinded: true
            isRule: true
          nodes #4: PEGActionNode
            action_string:  return new VirtualParamNode(t, n.text, dv, false); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: n
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new VirtualParamNode(t, n.text, null, true); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: n
            isBinded: true
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new VirtualParamNode(t, n.text, null, false); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new VirtualParamNode(t, null, null, true); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return new VirtualParamNode(t, null, null, false); 
    rules #77: RuleNode
      ruleName: literal_varg_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  VirtualParamNode[] params; 
        nodes #1: PEGElementNode
          elementName: literal_varg
          binderName: p1
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  params ~= p1; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: literal_varg
              binderName: p2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  params ~= p2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return params; 
    rules #78: RuleNode
      ruleName: literal_varg
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #4: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #5: PEGActionNode
            action_string:  return new VirtualParamNode(t, id.text, e, true); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #4: PEGActionNode
            action_string:  return new VirtualParamNode(t, id.text, e, false); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return new VirtualParamNode(t, id.text, null, true); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: type
            binderName: t
            isBinded: true
            isRule: true
          nodes #1: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new VirtualParamNode(t, id.text, null, false); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #4: PEGActionNode
            action_string:  return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, e, true); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: EQUAL
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #3: PEGActionNode
            action_string:  return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, e, false); 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: PERIOD3
            isBinded: false
            isRule: false
          nodes #2: PEGActionNode
            action_string:  return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, null, true); 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, null, false); 
    rules #79: RuleNode
      ruleName: assoc_array_element_list
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  AssocArrayElementNode[] nodes; 
        nodes #1: PEGElementNode
          elementName: assoc_array_element
          binderName: n
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  nodes ~= n; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: assoc_array_element
              binderName: n2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  nodes ~= n2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return nodes; 
    rules #80: RuleNode
      ruleName: assoc_array_element
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: expression
          binderName: k
          isBinded: true
          isRule: true
        nodes #1: PEGElementNode
          elementName: COLON
          isBinded: false
          isRule: false
        nodes #2: PEGElementNode
          elementName: expression
          binderName: v
          isBinded: true
          isRule: true
        nodes #3: PEGActionNode
          action_string:  return new AssocArrayElementNode(k, v); 
    rules #81: RuleNode
      ruleName: class_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FINAL
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Final); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STATIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Static); 
    rules #82: RuleNode
      ruleName: trait_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STATIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Static); 
    rules #83: RuleNode
      ruleName: enum_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STATIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Static); 
    rules #84: RuleNode
      ruleName: template_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
    rules #85: RuleNode
      ruleName: alias_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
    rules #86: RuleNode
      ruleName: type_qualifier
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: CONST
          binderName: t
          isBinded: true
          isRule: false
        nodes #1: PEGActionNode
          action_string:  return Qualifier(t.location, Qualifiers.Const); 
    rules #87: RuleNode
      ruleName: field_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PROTECTED
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Protected); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STATIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Static); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FINAL
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Final); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CONST
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Const); 
    rules #88: RuleNode
      ruleName: method_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PROTECTED
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Protected); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STATIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Static); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: FINAL
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Final); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CONST
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Const); 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: OVERRIDE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Override); 
    rules #89: RuleNode
      ruleName: ctor_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PUBLIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Public); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PROTECTED
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Protected); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CONST
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Const); 
    rules #90: RuleNode
      ruleName: lvar_qualifier
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PRIVATE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Private); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: PROTECTED
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Protected); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CONST
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Const); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: STATIC
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return Qualifier(t.location, Qualifiers.Static); 
    rules #91: RuleNode
      ruleName: def_id
      typeName: DefinitionIdentifierNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGElementNode
            elementName: LBR
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: def_id_arg_list
            binderName: params
            isBinded: true
            isRule: true
          nodes #3: PEGElementNode
            elementName: RBR
            isBinded: false
            isRule: false
          nodes #4: PEGActionNode
            action_string:  return new DefinitionIdentifierNode(id.location, id.text, params); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGSkippableNode
            inner: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LBR
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: RBR
                isBinded: false
                isRule: false
          nodes #2: PEGActionNode
            action_string:  return new DefinitionIdentifierNode(id.location, id.text, null); 
    rules #92: RuleNode
      ruleName: def_id_arg_list
      typeName: DefinitionIdentifierParamNode[]
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  DefinitionIdentifierParamNode[] nodes; 
        nodes #1: PEGElementNode
          elementName: def_id_arg
          binderName: first_t
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  nodes ~= first_t; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: def_id_arg
              binderName: second_t
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  nodes ~= second_t; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return nodes; 
    rules #93: RuleNode
      ruleName: def_id_arg
      typeName: DefinitionIdentifierParamNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: def_id_argname
          binderName: n
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: EQUAL
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: type
                binderName: t
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  n = n.withDefaultValue(t); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: COLON
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: type
                binderName: t
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  n = n.withExtendedFrom(t); 
            nodes #2: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: RARROW
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: type
                binderName: t
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  n = n.withCastableTo(t); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return n; 
    rules #94: RuleNode
      ruleName: def_id_argname
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: IDENTIFIER
          binderName: t
          isBinded: true
          isRule: false
        nodes #1: PEGActionNode
          action_string:  return new DefinitionIdentifierParamNode(t.location, t.text); 
    rules #95: RuleNode
      ruleName: type
      typeName: TypeNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  auto tq = Qualifier(Location(int.max, int.max), 0); bool hasQualifier = false; 
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: type_qualifier
              binderName: tqq
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  tq = tq.combine(tqq); hasQualifier = true; 
          isRequiredLeastOne: false
        nodes #2: PEGElementNode
          elementName: type_body
          binderName: tb
          isBinded: true
          isRule: true
        nodes #3: PEGActionNode
          action_string:  return hasQualifier ? new QualifiedTypeNode(tq, tb) : tb; 
    rules #96: RuleNode
      ruleName: type_body
      typeName: auto
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: type_body_base
          binderName: tbb
          isBinded: true
          isRule: true
        nodes #1: PEGSkippableNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: FUNCTION
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: LP
                isBinded: false
                isRule: false
              nodes #2: PEGElementNode
                elementName: varg_list
                binderName: vpl
                isBinded: true
                isRule: true
              nodes #3: PEGElementNode
                elementName: RP
                isBinded: false
                isRule: false
              nodes #4: PEGActionNode
                action_string:  tbb = new FunctionTypeNode(tbb, vpl); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: FUNCTION
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: LP
                isBinded: false
                isRule: false
              nodes #2: PEGElementNode
                elementName: RP
                isBinded: false
                isRule: false
              nodes #3: PEGActionNode
                action_string:  tbb = new FunctionTypeNode(tbb, null); 
        nodes #2: PEGActionNode
          action_string:  return tbb; 
    rules #97: RuleNode
      ruleName: type_body_base
      typeName: auto
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: AUTO
            binderName: a
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new InferenceTypeNode(a.location); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: restricted_type
            binderName: rt
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return rt; 
    rules #98: RuleNode
      ruleName: restricted_type
      typeName: TypeNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: primitive_types
          binderName: pt
          isBinded: true
          isRule: true
        nodes #1: PEGLoopQualifiedNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LBR
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: expression
                binderName: e
                isBinded: true
                isRule: true
              nodes #2: PEGElementNode
                elementName: RBR
                isBinded: false
                isRule: false
              nodes #3: PEGActionNode
                action_string:  pt = new ArrayTypeNode(pt, e); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: LBR
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: RBR
                isBinded: false
                isRule: false
              nodes #2: PEGActionNode
                action_string:  pt = new ArrayTypeNode(pt, null); 
          isRequiredLeastOne: false
        nodes #2: PEGActionNode
          action_string:  return pt; 
    rules #99: RuleNode
      ruleName: primitive_types
      typeName: TypeNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: register_types
            binderName: rt
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return rt; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: template_instance
            binderName: ti
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return ti; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: __typeof
            binderName: to
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return to; 
    rules #100: RuleNode
      ruleName: __typeof
      typeName: TypeofNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: TYPEOF
          binderName: f
          isBinded: true
          isRule: false
        nodes #1: PEGElementNode
          elementName: LP
          isBinded: false
          isRule: false
        nodes #2: PEGSwitchingNode
          nodes #0: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: expression
              binderName: e
              isBinded: true
              isRule: true
            nodes #1: PEGElementNode
              elementName: RP
              isBinded: false
              isRule: false
            nodes #2: PEGActionNode
              action_string:  return new TypeofNode(f.location, e); 
          nodes #1: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: restricted_type
              binderName: rt
              isBinded: true
              isRule: true
            nodes #1: PEGElementNode
              elementName: RP
              isBinded: false
              isRule: false
            nodes #2: PEGActionNode
              action_string:  return new TypeofNode(f.location, rt); 
    rules #101: RuleNode
      ruleName: register_types
      typeName: RegisterTypeNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: VOID
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Void); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: CHAR
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Char); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: UCHAR
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Uchar); 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: BYTE
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Byte); 
        nodes #4: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SHORT
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Short); 
        nodes #5: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: USHORT
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Ushort); 
        nodes #6: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: INT
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Int); 
        nodes #7: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: UINT
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Uint); 
        nodes #8: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: LONG
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Long); 
        nodes #9: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: ULONG
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Ulong); 
    rules #102: RuleNode
      ruleName: template_instance
      typeName: TemplateInstanceTypeNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGElementNode
          elementName: IDENTIFIER
          binderName: t
          isBinded: true
          isRule: false
        nodes #1: PEGSkippableNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: template_tail
              binderName: v
              isBinded: true
              isRule: true
            nodes #1: PEGActionNode
              action_string:  return new TemplateInstanceTypeNode(t.location, t.text, v); 
        nodes #2: PEGActionNode
          action_string:  return new TemplateInstanceTypeNode(t.location, t.text, null); 
    rules #103: RuleNode
      ruleName: template_tail
      typeName: TemplateParamNode[]
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SHARP
            isBinded: false
            isRule: false
          nodes #1: PEGElementNode
            elementName: single_types
            binderName: st
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return [new TemplateParamNode(st.location, st)]; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SHARP
            isBinded: false
            isRule: false
          nodes #1: PEGElementNode
            elementName: primary_expr
            binderName: pe
            isBinded: true
            isRule: true
          nodes #2: PEGActionNode
            action_string:  return [new TemplateParamNode(pe.location, pe)]; 
        nodes #2: PEGSequentialNode
          nodes #0: PEGActionNode
            action_string:  TemplateParamNode[] params; 
          nodes #1: PEGElementNode
            elementName: SHARP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #3: PEGElementNode
            elementName: template_param
            binderName: first_t
            isBinded: true
            isRule: true
          nodes #4: PEGActionNode
            action_string:  params ~= first_t; 
          nodes #5: PEGLoopQualifiedNode
            inner: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: COMMA
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: template_param
                binderName: second_t
                isBinded: true
                isRule: true
              nodes #2: PEGActionNode
                action_string:  params ~= second_t; 
            isRequiredLeastOne: false
          nodes #6: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #7: PEGActionNode
            action_string:  return params; 
        nodes #3: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: SHARP
            isBinded: false
            isRule: false
          nodes #1: PEGElementNode
            elementName: LP
            isBinded: false
            isRule: false
          nodes #2: PEGElementNode
            elementName: RP
            isBinded: false
            isRule: false
          nodes #3: PEGActionNode
            action_string:  return null; 
    rules #104: RuleNode
      ruleName: template_param
      typeName: TemplateParamNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: id
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new TemplateParamNode(id.location, id.text); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: restricted_type
            binderName: rt
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return new TemplateParamNode(rt.location, rt); 
        nodes #2: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: expression
            binderName: e
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return new TemplateParamNode(e.location, e); 
    rules #105: RuleNode
      ruleName: single_types
      typeName: TypeNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: AUTO
            binderName: a
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new InferenceTypeNode(a.location); 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: single_restricted_type
            binderName: srt
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return srt; 
    rules #106: RuleNode
      ruleName: single_restricted_type
      typeName: TypeNode
      ruleBody: PEGSwitchingNode
        nodes #0: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: register_types
            binderName: rt
            isBinded: true
            isRule: true
          nodes #1: PEGActionNode
            action_string:  return rt; 
        nodes #1: PEGSequentialNode
          nodes #0: PEGElementNode
            elementName: IDENTIFIER
            binderName: t
            isBinded: true
            isRule: false
          nodes #1: PEGActionNode
            action_string:  return new TemplateInstanceTypeNode(t.location, t.text, null); 
    rules #107: RuleNode
      ruleName: import_list
      typeName: ImportUnitNode[]
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  ImportUnitNode[] ius; 
        nodes #1: PEGElementNode
          elementName: import_item
          binderName: ii
          isBinded: true
          isRule: true
        nodes #2: PEGActionNode
          action_string:  ius ~= ii; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: COMMA
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: import_item
              binderName: ii2
              isBinded: true
              isRule: true
            nodes #2: PEGActionNode
              action_string:  ius ~= ii2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return ius; 
    rules #108: RuleNode
      ruleName: import_item
      typeName: ImportUnitNode
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  string[] ppath; 
        nodes #1: PEGElementNode
          elementName: IDENTIFIER
          binderName: ft
          isBinded: true
          isRule: false
        nodes #2: PEGActionNode
          action_string:  ppath ~= ft.text; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: PERIOD
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: IDENTIFIER
              binderName: st
              isBinded: true
              isRule: false
            nodes #2: PEGActionNode
              action_string:  ppath ~= st.text; 
          isRequiredLeastOne: false
        nodes #4: PEGSkippableNode
          inner: PEGSwitchingNode
            nodes #0: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PERIOD
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: ASTERISK
                isBinded: false
                isRule: false
              nodes #2: PEGActionNode
                action_string:  return new ImportUnitNode(ft.location, ppath, true); 
            nodes #1: PEGSequentialNode
              nodes #0: PEGElementNode
                elementName: PERIOD
                isBinded: false
                isRule: false
              nodes #1: PEGElementNode
                elementName: LB
                isBinded: false
                isRule: false
              nodes #2: PEGElementNode
                elementName: import_list
                binderName: sps
                isBinded: true
                isRule: true
              nodes #3: PEGElementNode
                elementName: RB
                isBinded: false
                isRule: false
              nodes #4: PEGActionNode
                action_string:  return new ImportUnitNode(ft.location, ppath, sps); 
        nodes #5: PEGActionNode
          action_string:  return new ImportUnitNode(ft.location, ppath, false); 
    rules #109: RuleNode
      ruleName: package_id
      typeName: Token[]
      ruleBody: PEGSequentialNode
        nodes #0: PEGActionNode
          action_string:  Token[] ids; 
        nodes #1: PEGElementNode
          elementName: IDENTIFIER
          binderName: t
          isBinded: true
          isRule: false
        nodes #2: PEGActionNode
          action_string:  ids ~= t; 
        nodes #3: PEGLoopQualifiedNode
          inner: PEGSequentialNode
            nodes #0: PEGElementNode
              elementName: PERIOD
              isBinded: false
              isRule: false
            nodes #1: PEGElementNode
              elementName: IDENTIFIER
              binderName: t2
              isBinded: true
              isRule: false
            nodes #2: PEGActionNode
              action_string:  ids ~= t2; 
          isRequiredLeastOne: false
        nodes #4: PEGActionNode
          action_string:  return ids; 
Tokenizer Pattern parsing...
PatternSwitchNode
  LiteralStringNode
    content:  
  LiteralStringNode
    content: \t
  LiteralStringNode
    content: \r
  LiteralStringNode
    content: \n
PatternSequenceNode
  LiteralStringNode
    content: /
  LiteralStringNode
    content: /
  ZeroLoopQualifiedPatternNode
    content: ExcludingPatternNode
      content: PatternSequenceNode
        LiteralStringNode
          content: \n
  LiteralStringNode
    content: \n
PatternSequenceNode
  LiteralStringNode
    content: /
  LiteralStringNode
    content: *
  ZeroLoopQualifiedPatternNode
    content: ExcludingPatternNode
      content: PatternSequenceNode
        LiteralStringNode
          content: *
        LiteralStringNode
          content: /
  LiteralStringNode
    content: *
  LiteralStringNode
    content: /
Exception in generating pattern table: shift/shift conflict on candidate /, state 0
LoopQualifiedPatternNode
  content: RangedLiteralNode
    left: LiteralStringNode
      content: 0
    right: LiteralStringNode
      content: 9
ReduceAction: registered INUMBER to 0
PatternSequenceNode
  LiteralStringNode
    content: 0
  LiteralStringNode
    content: x
  LoopQualifiedPatternNode
    content: PatternSwitchNode
      RangedLiteralNode
        left: LiteralStringNode
          content: 0
        right: LiteralStringNode
          content: 9
      RangedLiteralNode
        left: LiteralStringNode
          content: A
        right: LiteralStringNode
          content: F
      RangedLiteralNode
        left: LiteralStringNode
          content: a
        right: LiteralStringNode
          content: f
ReduceAction: registered HNUMBER to 1
Info: overwriting reduce by shift. on candidate 0, state 0
PatternSequenceNode
  ZeroLoopQualifiedPatternNode
    content: RangedLiteralNode
      left: LiteralStringNode
        content: 0
      right: LiteralStringNode
        content: 9
  LiteralStringNode
    content: .
  LoopQualifiedPatternNode
    content: RangedLiteralNode
      left: LiteralStringNode
        content: 0
      right: LiteralStringNode
        content: 9
  PatternSwitchNode
    LiteralStringNode
      content: F
    LiteralStringNode
      content: f
ReduceAction: registered FNUMBER to 2
Exception in generating pattern table: shift/shift conflict on candidate 0, state 0
PatternSequenceNode
  ZeroLoopQualifiedPatternNode
    content: RangedLiteralNode
      left: LiteralStringNode
        content: 0
      right: LiteralStringNode
        content: 9
  LiteralStringNode
    content: .
  LoopQualifiedPatternNode
    content: RangedLiteralNode
      left: LiteralStringNode
        content: 0
      right: LiteralStringNode
        content: 9
  PatternSwitchNode
    LiteralStringNode
      content: D
    LiteralStringNode
      content: d
ReduceAction: registered DNUMBER to 3
Exception in generating pattern table: shift/shift conflict on candidate 0, state 0
PatternSequenceNode
  ZeroLoopQualifiedPatternNode
    content: RangedLiteralNode
      left: LiteralStringNode
        content: 0
      right: LiteralStringNode
        content: 9
  LiteralStringNode
    content: .
  LoopQualifiedPatternNode
    content: RangedLiteralNode
      left: LiteralStringNode
        content: 0
      right: LiteralStringNode
        content: 9
ReduceAction: registered NUMBER to 4
Exception in generating pattern table: shift/shift conflict on candidate 0, state 0
PatternSequenceNode
  LiteralStringNode
    content: \"
  ZeroLoopQualifiedPatternNode
    content: PatternSwitchNode
      PatternSequenceNode
        LiteralStringNode
          content: \\
        AnyCharacterNode
      ExcludingPatternNode
        content: PatternSequenceNode
          LiteralStringNode
            content: \"
  LiteralStringNode
    content: \"
ReduceAction: registered STRING to 5
PatternSequenceNode
  LiteralStringNode
    content: '
  ZeroLoopQualifiedPatternNode
    content: ExcludingPatternNode
      content: LiteralStringNode
        content: '
  LiteralStringNode
    content: '
ReduceAction: registered CHARACTER to 6
PatternSequenceNode
  PatternSwitchNode
    RangedLiteralNode
      left: LiteralStringNode
        content: A
      right: LiteralStringNode
        content: Z
    RangedLiteralNode
      left: LiteralStringNode
        content: a
      right: LiteralStringNode
        content: z
    LiteralStringNode
      content: _
  ZeroLoopQualifiedPatternNode
    content: PatternSwitchNode
      RangedLiteralNode
        left: LiteralStringNode
          content: A
        right: LiteralStringNode
          content: Z
      RangedLiteralNode
        left: LiteralStringNode
          content: a
        right: LiteralStringNode
          content: z
      RangedLiteralNode
        left: LiteralStringNode
          content: 0
        right: LiteralStringNode
          content: 9
      LiteralStringNode
        content: _
ReduceAction: registered IDENTIFIER to 7
LiteralStringNode
  content: ;
ReduceAction: registered SEMICOLON to 8
LiteralStringNode
  content: .
ReduceAction: registered PERIOD to 9
LiteralStringNode
  content: ,
ReduceAction: registered COMMA to 10
LiteralStringNode
  content: :
ReduceAction: registered COLON to 11
PatternSequenceNode
  LiteralStringNode
    content: -
  LiteralStringNode
    content: >
ReduceAction: registered RARROW to 12
PatternSequenceNode
  LiteralStringNode
    content: =
  LiteralStringNode
    content: >
ReduceAction: registered RARROW2 to 13
PatternSequenceNode
  LiteralStringNode
    content: <
  LiteralStringNode
    content: -
ReduceAction: registered LARROW to 14
LiteralStringNode
  content: #
ReduceAction: registered SHARP to 15
LiteralStringNode
  content: =
ReduceAction: registered EQUAL to 16
Warn: overwriting shift by reduce is not allowed. ignored. on candidate =, state 0
PatternSequenceNode
  LiteralStringNode
    content: +
  LiteralStringNode
    content: =
ReduceAction: registered PLUS_EQ to 17
PatternSequenceNode
  LiteralStringNode
    content: -
  LiteralStringNode
    content: =
ReduceAction: registered MINUS_EQ to 18
Exception in generating pattern table: shift/shift conflict on candidate -, state 0
PatternSequenceNode
  LiteralStringNode
    content: *
  LiteralStringNode
    content: =
ReduceAction: registered ASTERISK_EQ to 19
PatternSequenceNode
  LiteralStringNode
    content: /
  LiteralStringNode
    content: =
ReduceAction: registered SLASH_EQ to 20
Exception in generating pattern table: shift/shift conflict on candidate /, state 0
PatternSequenceNode
  LiteralStringNode
    content: %
  LiteralStringNode
    content: =
ReduceAction: registered PERCENT_EQ to 21
PatternSequenceNode
  LiteralStringNode
    content: &
  LiteralStringNode
    content: =
ReduceAction: registered AMPASAND_EQ to 22
PatternSequenceNode
  LiteralStringNode
    content: |
  LiteralStringNode
    content: =
ReduceAction: registered VL_EQ to 23
PatternSequenceNode
  LiteralStringNode
    content: ^
  LiteralStringNode
    content: =
ReduceAction: registered CA_EQ to 24
PatternSequenceNode
  LiteralStringNode
    content: <
  LiteralStringNode
    content: <
  LiteralStringNode
    content: =
ReduceAction: registered LAB2_EQ to 25
Exception in generating pattern table: shift/shift conflict on candidate <, state 0
PatternSequenceNode
  LiteralStringNode
    content: >
  LiteralStringNode
    content: >
  LiteralStringNode
    content: =
ReduceAction: registered RAB2_EQ to 26
PatternSequenceNode
  LiteralStringNode
    content: &
  LiteralStringNode
    content: &
ReduceAction: registered AMPASAND2 to 27
Exception in generating pattern table: shift/shift conflict on candidate &, state 0
PatternSequenceNode
  LiteralStringNode
    content: |
  LiteralStringNode
    content: |
ReduceAction: registered VL2 to 28
Exception in generating pattern table: shift/shift conflict on candidate |, state 0
PatternSequenceNode
  LiteralStringNode
    content: ^
  LiteralStringNode
    content: ^
ReduceAction: registered CA2 to 29
Exception in generating pattern table: shift/shift conflict on candidate ^, state 0
LiteralStringNode
  content: +
ReduceAction: registered PLUS to 30
Warn: overwriting shift by reduce is not allowed. ignored. on candidate +, state 0
LiteralStringNode
  content: -
ReduceAction: registered MINUS to 31
Warn: overwriting shift by reduce is not allowed. ignored. on candidate -, state 0
LiteralStringNode
  content: *
ReduceAction: registered ASTERISK to 32
Warn: overwriting shift by reduce is not allowed. ignored. on candidate *, state 0
LiteralStringNode
  content: /
ReduceAction: registered SLASH to 33
Warn: overwriting shift by reduce is not allowed. ignored. on candidate /, state 0
LiteralStringNode
  content: %
ReduceAction: registered PERCENT to 34
Warn: overwriting shift by reduce is not allowed. ignored. on candidate %, state 0
LiteralStringNode
  content: &
ReduceAction: registered AMPASAND to 35
Warn: overwriting shift by reduce is not allowed. ignored. on candidate &, state 0
LiteralStringNode
  content: |
ReduceAction: registered VL to 36
Warn: overwriting shift by reduce is not allowed. ignored. on candidate |, state 0
LiteralStringNode
  content: ^
ReduceAction: registered CA to 37
Warn: overwriting shift by reduce is not allowed. ignored. on candidate ^, state 0
PatternSequenceNode
  LiteralStringNode
    content: <
  LiteralStringNode
    content: <
ReduceAction: registered LAB2 to 38
Exception in generating pattern table: shift/shift conflict on candidate <, state 0
PatternSequenceNode
  LiteralStringNode
    content: >
  LiteralStringNode
    content: >
ReduceAction: registered RAB2 to 39
Exception in generating pattern table: shift/shift conflict on candidate >, state 0
LiteralStringNode
  content: <
ReduceAction: registered LAB to 40
Warn: overwriting shift by reduce is not allowed. ignored. on candidate <, state 0
LiteralStringNode
  content: >
ReduceAction: registered RAB to 41
Warn: overwriting shift by reduce is not allowed. ignored. on candidate >, state 0
PatternSequenceNode
  LiteralStringNode
    content: <
  LiteralStringNode
    content: =
ReduceAction: registered LAB_EQ to 42
Info: overwriting reduce by shift. on candidate <, state 0
PatternSequenceNode
  LiteralStringNode
    content: >
  LiteralStringNode
    content: =
ReduceAction: registered RAB_EQ to 43
Info: overwriting reduce by shift. on candidate >, state 0
PatternSequenceNode
  LiteralStringNode
    content: =
  LiteralStringNode
    content: =
ReduceAction: registered EQ2 to 44
Info: overwriting reduce by shift. on candidate =, state 0
PatternSequenceNode
  LiteralStringNode
    content: !
  LiteralStringNode
    content: =
ReduceAction: registered EX_EQ to 45
LiteralStringNode
  content: ?
ReduceAction: registered QUESTION to 46
PatternSequenceNode
  LiteralStringNode
    content: +
  LiteralStringNode
    content: +
ReduceAction: registered PLUS2 to 47
Info: overwriting reduce by shift. on candidate +, state 0
PatternSequenceNode
  LiteralStringNode
    content: -
  LiteralStringNode
    content: -
ReduceAction: registered MINUS2 to 48
Info: overwriting reduce by shift. on candidate -, state 0
PatternSequenceNode
  LiteralStringNode
    content: *
  LiteralStringNode
    content: *
ReduceAction: registered ASTERISK2 to 49
Info: overwriting reduce by shift. on candidate *, state 0
PatternSequenceNode
  LiteralStringNode
    content: .
  LiteralStringNode
    content: .
ReduceAction: registered PERIOD2 to 50
Info: overwriting reduce by shift. on candidate ., state 0
PatternSequenceNode
  LiteralStringNode
    content: .
  LiteralStringNode
    content: .
  LiteralStringNode
    content: .
ReduceAction: registered PERIOD3 to 51
Exception in generating pattern table: shift/shift conflict on candidate ., state 0
LiteralStringNode
  content: (
ReduceAction: registered LP to 52
LiteralStringNode
  content: )
ReduceAction: registered RP to 53
LiteralStringNode
  content: {
ReduceAction: registered LB to 54
LiteralStringNode
  content: }
ReduceAction: registered RB to 55
LiteralStringNode
  content: [
ReduceAction: registered LBR to 56
LiteralStringNode
  content: ]
ReduceAction: registered RBR to 57
--- Shift Table ---
+-------+--+--+--+--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| state |  |\t|\r|\n| / | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | x | A | B | C | D | E | F | a | b | c | d | e | f | " | \ | ' | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | y | z | _ |; | . | , | : | - | > | = | < | # | + | * | % | & | | | ^ | ! | ? | ( | ) | { | } | [ | ] |
+-------+--+--+--+--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|   0   |rX|rX|rX|rX|r33|s7 |r0 |r0 |r0 |r0 |r0 |r0 |r0 |r0 |r0 |s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s13|   |s19|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|s22|r8|s67|r10|r11|s63|s55|s57|s53|r15|s61|s65|r34|r35|r36|r37|s59|r46|r52|r53|r54|r55|r56|r57|
|   1   |  |  |  |  |s2 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   2   |  |  |  |s4|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   3   |  |  |  |s5|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   4   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   5   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   6   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   7   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |s8 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   8   |  |  |  |  |   |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |   |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |s9 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|   9   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  10   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  11   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  12   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  13   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |s15|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  14   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |s18|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  15   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  16   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |s17|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  17   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  18   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  19   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |s20|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  20   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |s21|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  21   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  22   |  |  |  |  |   |s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|   |   |   |s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|s23|  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  23   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  24   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |s25|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  25   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  26   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |s27|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  27   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  28   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |s29|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  29   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  30   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s31|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  31   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  32   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  33   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s34|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  34   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  35   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  36   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s37|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  37   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  38   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s39|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  39   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  40   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s41|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  41   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  42   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s43|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  43   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  44   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  45   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |s46|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  46   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s47|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  47   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  48   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  49   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  50   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  51   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  52   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  53   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s54|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  54   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  55   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s56|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  56   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  57   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s58|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  58   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  59   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |s60|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  60   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  61   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |s62|   |   |   |   |   |   |   |   |   |   |   |   |   |
|  62   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  63   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |s64|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  64   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  65   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |s66|   |   |   |   |   |   |   |   |   |   |   |   |
|  66   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  67   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |s68|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  68   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|  69   |  |  |  |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
+-------+--+--+--+--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--- Reduce Table ---
+-------+-------------+
| state |   target    |
+-------+-------------+
|   0   |   INUMBER   |
|   1   |   HNUMBER   |
|   2   |   FNUMBER   |
|   3   |   DNUMBER   |
|   4   |   NUMBER    |
|   5   |   STRING    |
|   6   |  CHARACTER  |
|   7   | IDENTIFIER  |
|   8   |  SEMICOLON  |
|   9   |   PERIOD    |
|  10   |    COMMA    |
|  11   |    COLON    |
|  12   |   RARROW    |
|  13   |   RARROW2   |
|  14   |   LARROW    |
|  15   |    SHARP    |
|  16   |    EQUAL    |
|  17   |   PLUS_EQ   |
|  18   |  MINUS_EQ   |
|  19   | ASTERISK_EQ |
|  20   |  SLASH_EQ   |
|  21   | PERCENT_EQ  |
|  22   | AMPASAND_EQ |
|  23   |    VL_EQ    |
|  24   |    CA_EQ    |
|  25   |   LAB2_EQ   |
|  26   |   RAB2_EQ   |
|  27   |  AMPASAND2  |
|  28   |     VL2     |
|  29   |     CA2     |
|  30   |    PLUS     |
|  31   |    MINUS    |
|  32   |  ASTERISK   |
|  33   |    SLASH    |
|  34   |   PERCENT   |
|  35   |  AMPASAND   |
|  36   |     VL      |
|  37   |     CA      |
|  38   |    LAB2     |
|  39   |    RAB2     |
|  40   |     LAB     |
|  41   |     RAB     |
|  42   |   LAB_EQ    |
|  43   |   RAB_EQ    |
|  44   |     EQ2     |
|  45   |    EX_EQ    |
|  46   |  QUESTION   |
|  47   |    PLUS2    |
|  48   |   MINUS2    |
|  49   |  ASTERISK2  |
|  50   |   PERIOD2   |
|  51   |   PERIOD3   |
|  52   |     LP      |
|  53   |     RP      |
|  54   |     LB      |
|  55   |     RB      |
|  56   |     LBR     |
|  57   |     RBR     |
+-------+-------------+
one or more errors detected. generator stopped.
