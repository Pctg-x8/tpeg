# Maple Latte Grammar declaration

package com.cterm2.ml

tokenizer
{
	module lexer

	skip_pattern	[ \t\r\n]
	skip_pattern	//[^\n]*\n
	skip_pattern	/*[^\*]*\*/
	patterns
	{
		INUMBER		[0-9]+
		HNUMBER		0x[0-9A-Fa-f]+
		FNUMBER		[0-9]*\.[0-9]+(f|F)
		DNUMBER		[0-9]*\.[0-9]+(d|D)
		NUMBER		[0-9]*\.[0-9]+
		STRING		@"[^"]*"
		CHARACTER	'[^']*'
		IDENTIFIER	[A-Za-z_][A-Za-z0-9_]*

		SEMICOLON	";"
		PERIOD		"."
		COMMA		","
		COLON		":"
		RARROW		"->"
		RARROW2		"=>"
		LARROW		"<-"
		SHARP		"#"
		EQUAL		"="
		PLUS_EQ		"+="
		MINUS_EQ	"-="
		ASTERISK_EQ	"*="
		SLASH_EQ	"/="
		PERCENT_EQ	"%="
		AMPASAND_EQ	"&="
		VL_EQ		"|="
		CA_EQ		"^="
		LAB2_EQ		"<<="
		RAB2_EQ		">>="

		AMPASAND2	"&&"
		VL2			"||"
		CA2			"^^"
		PLUS		"+"
		MINUS		"-"
		ASTERISK	"*"
		SLASH		"/"
		PERCENT		"%"
		AMPASAND	"&"
		VL			"|"
		CA			"^"
		LAB2		"<<"
		RAB2		">>"
		LAB			"<"
		RAB			">"
		LAB_EQ		"<="
		RAB_EQ		">="
		EQ2			"=="
		EX_EQ		"!="
		QUESTION	"?"
		PLUS2		"++"
		MINUS2		"--"
		ASTERISK2	"**"

		PERIOD2		".."
		PERIOD3		"..."

		LP			"("
		RP			")"
		LB			"{"
		RB			"}"
		LBR			"["
		RBR			"]"

		# keywords
		PACKAGE		"package"
		IMPORT		"import"
		CLASS		"class"
		TRAIT		"trait"
		ENUM		"enum"
		EXTENDS		"extends"
		WITH		"with"
		TEMPLATE	"template"
		ALIAS		"alias"
		PROPERTY	"property"
		FUNCTION	"funcion"

		IF			"if"
		ELSE		"else"
		WHILE		"while"
		DO			"do"
		FOREACH		"foreach"
		FOR			"for"
		RETURN		"return"
		BREAK		"break"
		CONTINUE	"continue"
		SWITCH		"switch"
		CASE		"case"
		DEFAULT		"default"

		TYPEOF		"typeof"
		THIS		"this"
		SUPER		"super"
		TRUE		"true"
		FALSE		"false"
		NULL		"null"

		PUBLIC		"public"
		PRIVATE		"private"
		PROTECTED	"protected"
		FINAL		"final"
		CONST		"const"
		STATIC		"static"
		OVERRIDE	"override"

		AUTO		"auto"
		VOID		"void"
		CHAR		"char"
		UCHAR		"uchar"
		BYTE		"byte"
		SHORT		"short"
		USHORT		"ushort"
		INT			"int"
		UINT		"uint"
		LONG		"long"
		ULONG		"ulong"
	}
}

parser
{
	module parser
	header
	{
import com.cterm2.ml.syntaxTree;
import std.typecons, std.conv;
	}

	start_rule compilation_unit
	rules
	{
		# entry #
		compilation_unit = [package_def] script_element*;
		package_def = PACKAGE package_id SEMICOLON;

		# declarations #
		script_element = import_decl / partial_package_def / class_def / trait_def / enum_def
		 	/ template_def / alias_def / class_body;
		import_decl = IMPORT import_list SEMICOLON;
		partial_package_def = PACKAGE package_id (script_element / LB script_element* RB);
		class_def = class_qualifier* CLASS def_id [EXTENDS type] (WITH type)*
			(SEMICOLON / LB (import_decl / class_body)* RB);
		class_body = field_def / method_def / property_def / ctor_def;
		trait_def = trait_qualifier* TRAIT def_id (WITH type)*
			(SEMICOLON / LB (import_decl / trait_body)* RB);
		trait_body = method_def / property_def / ctor_def;
		enum_def = enum_qualifier* ENUM IDENTIFIER
			(SEMICOLON / LB import_decl* [enum_body] (import_decl / class_body)* RB);
		enum_body = enum_element (COMMA enum_element)* [COMMA / SEMICOLON];
		enum_element = IDENTIFIER [LP expression_list RP];
		template_def = template_qualifier* TEMPLATE IDENTIFIER LP [template_arg_list] RP
			(SEMICOLON / template_body / LB template_body* RB);
		template_body = import_decl / class_def / trait_def / enum_def / template_def / alias_def;
		alias_def = alias_qualifier* ALIAS (IDENTIFIER EQUAL type / type IDENTIFIER);

		# body declarations #
		field_def = (field_qualifier* type / field_qualifier+) field_def_list SEMICOLON;
		field_def_list = nvpair (COMMA nvpair)*;
		nvpair = IDENTIFIER [EQUAL expression];
		method_def = function_def / procedure_def / abstract_method_def;
		procedure_def = (method_qualifier* type / method_qualifier+) def_id LP [varg_list] RP statement;
		function_def = (method_qualifier* type / method_qualifier+) def_id LP [varg_list] RP EQUAL expression SEMICOLON;
		abstract_method_def = (method_qualifier* type / method_qualifier+) def_id LP [varg_list] RP SEMICOLON;
		property_def = getter_def / setter_def;
		setter_def = method_qualifier* PROPERTY [type] def_id LP type IDENTIFIER RP
			(statement / SEMICOLON);
		getter_def = method_qualifier* PROPERTY [type] def_id [LP RP]
			(EQUAL expression SEMICOLON / statement / SEMICOLON);
		ctor_def = ctor_qualifier* THIS LP [varg_list] RP
			(statement / SEMICOLON);

		# statements #
		statement = if_stmt / while_stmt / do_stmt / foreach_stmt / for_stmt / return_stmt /
			break_stmt / continue_stmt / label_stmt / switch_stmt / block_stmt / expression SEMICOLON / SEMICOLON;
		if_stmt = IF LP expression RP statement [ELSE statement];
		while_stmt = WHILE LP expression RP statement;
		do_stmt = DO statement WHILE LP expression RP SEMICOLON;
		foreach_stmt = FOREACH LP [type] IDENTIFIER LARROW expression RP statement;
		for_stmt = FOR LP [expression] SEMICOLON [expression] SEMICOLON [expression] RP statement;
		return_stmt = RETURN [expression] SEMICOLON;
		break_stmt = BREAK [IDENTIFIER] SEMICOLON;
		continue_stmt = CONTINUE [IDENTIFIER] SEMICOLON;
		label_stmt = IDENTIFIER COLON;
		switch_stmt = SWITCH LP expression RP LB (case_stmt / default_stmt)* RB;
		case_stmt = CASE (expression_list / [CONST] def_id COLON type [IF expression]) RARROW2 statement;
		default_stmt = DEFAULT RARROW2 statement;
		block_stmt = LBR (localvar_def / statement)* RBR;
		localvar_def = (lvar_qualifier* type / lvar_qualifier+) nvpair (COMMA nvpair)* SEMICOLON;

		# expressions #
		expression_list = expression (COMMA expression)*;
		expression = postfix_expr (EQUAL / assign_ops) expression / alternate_expr;
		assign_ops = PLUS_EQ / MINUS_EQ / ASTERISK_EQ / SLASH_EQ / PERCENT_EQ / AMPASAND_EQ / VL_EQ / CA_EQ
			/ LAB2_EQ / RAB2_EQ;
		alternate_expr = short_expr [QUESTION short_expr COLON short_expr];
		short_expr = comp_expr (AMPASAND2 comp_expr / VL2 comp_expr / CA2 comp_expr)*;
		comp_expr = shift_expr (LAB shift_expr / RAB shift_expr / EQ2 shift_expr
			/ EX_EQ shift_expr / LAB_EQ shift_expr / RAB_EQ shift_expr)*;
		shift_expr = bit_expr (LAB2 bit_expr / RAB2 bit_expr)*;
		bit_expr = a1_expr (AMPASAND a1_expr / VL a1_expr / CA a1_expr)*;
		a1_expr = a2_expr (PLUS a2_expr / MINUS a2_expr)*;
		a2_expr = range_expr (ASTERISK range_expr / SLASH range_expr / PERCENT range_expr)*;
		range_expr = prefix_expr (PERIOD2 prefix_expr)*;
		prefix_expr = PLUS prefix_expr / MINUS prefix_expr
			/ PLUS2 prefix_expr / MINUS2 prefix_expr / ASTERISK2 / prefix_expr / postfix_expr;
		postfix_expr = primary_expr (PLUS2 / MINUS2 / ASTERISK2
			/ LBR [expression] RBR / LP [expression_list] RP
			/ PERIOD IDENTIFIER [template_tail] / RARROW (single_types / LP restricted_type RP))*;
		primary_expr<ExpressionNode> =
			  literals:l						{ return l; }
			/ special_literals:sl				{ return sl; }
			/ lambda_expr:le					{ return le; }
			/ LP expression:e RP				{ return e; }
			/ IDENTIFIER:id template_tail:tt	{ return new TemplateInstantiateNode(id.location, id.text, tt); }
			/ IDENTIFIER:id						{ return new IdentifierReferenceNode(id.location, id.text); };
		literals<ExpressionNode> =
			  INUMBER:t				{ return new IntLiteralNode(t.location, t.text.to!int); }
			/ HNUMBER:t				{ return new IntLiteralNode(t.location, t.text.to!int(16)); }
			/ FNUMBER:t				{ return new FloatLiteralNode(t.location, t.text.to!float); }
			/ DNUMBER:t				{ return new DoubleLiteralNode(t.location, t.text.to!double); }
			/ NUMBER:t				{ return new NumericLiteralNode(t.location, t.text.to!real); }
			/ STRING:t				{ return new StringLiteralNode(t.location, t.text); }
			/ CHARACTER:t			{ return new CharacterLiteralNode(t.location, t.text[0]); }
			/ function_literal:fl	{ return fl; }
			/ array_literal:al		{ return al; };
		function_literal =
			  FUNCTION:f LP literal_varg_list:vl RP block_stmt:bs	{ return new FunctionLiteralNode(f.location, vl, bs); }
			/ FUNCTION:f LP RP block_stmt:bs						{ return new FunctionLiteralNode(f.location, null, bs); };
		array_literal =
			  LBR:ft expression_list:el RBR { return new ArrayLiteralNode(ft.location, el); }
			/ LBR:ft assoc_array_element_list:el RBR { return new AssocArrayLiteralNode(ft.location, el); }
			/ LBR:ft RBR { return new ArrayLiteralNode(ft.location, null); };
		special_literals<ExpressionNode> =
			  THIS:t		{ return new ThisReferenceNode(t.location); }
			/ SUPER:t		{ return new SuperReferenceNode(t.location); }
			/ TRUE:t		{ return new BooleanLiteralNode(t.location, true); }
			/ FALSE:t		{ return new BooleanLiteralNode(t.location, false); }
			/ NULL:t		{ return new NullLiteralNode(t.location); };
		lambda_expr =
			  LP:t literal_varg_list:ps RP RARROW2 expression:e { return new FunctionLiteralNode(t.location, ps, e); }
			/ LP:t RP RARROW2 expression:e { return new FunctionLiteralNode(t.location, null, e); }
			/ literal_varg:vp RARROW2 expression:e { return new FunctionLiteralNode(vp, e); };

		# arglists #
		template_arg_list = { TemplateVirtualParamNode[] params; }
			template_arg:p { params ~= p; } (COMMA template_arg:p2 { params ~= p2; })* { return params; };
		template_arg = template_arg_head:head (EQUAL type:t { head = new TemplataeVirtualParamNode(head, t); })* { return head; };
		template_arg_type = { alias ReturnType = Tuple!(TemplateVirtualParamNode.ParamType, "type", TypeNode, "stype", Location, "location"); }
			( type:t { return ReturnType(TemplateVirtualParamNode.ParamType.Type, t, t.location); }
			/ CLASS:tk { return ReturnType(TemplateVirtualParamNode.ParamType.Class, null, tk.location); }
			/ ALIAS:tk { return ReturnType(TemplateVirutalParamNode.ParamType.SymbolAlias, null, tk.location); });
		template_arg_head =
			  template_arg_type:type IDENTIFIER:id	{ return new TemplateVirtualParamNode(type.location, type.type, type.stype, id.text); }
			/ IDENTIFIER:id							{ return new TemplateVirutalParamNode(id.location, TemplateVirtualParamNode.ParamType.Any, null, id.text); };
		varg_list = { VirtualParamNode params[]; }
			varg:t { params ~= t; } (COMMA varg:v { params ~= v; })* { return params; };
		varg = type:t IDENTIFIER:n EQUAL expression:dv PERIOD3 { return new VirtualParamNode(t, n.text, dv, true); }
			/ type:t IDENTIFIER:n EQUAL expression:dv { return new VirtualParamNode(t, n.text, dv, false); }
			/ type:t IDENTIFIER:n PERIOD3 { return new VirtualParamNode(t, n.text, null, true); }
			/ type:t IDENTIFIER:n { return new VirtualParamNode(t, n.text, null, false); }
			/ type:t PERIOD3 { return new VirtualParamNode(t, null, null, true); }
			/ type:t { return new VirtualParamNode(t, null, null, false); };
		literal_varg_list = { VirtualParamNode[] params; }
			literal_varg:p1 { params ~= p1; } (COMMA literal_varg:p2 { params ~= p2; })* { return params; };
		literal_varg =
			  type:t IDENTIFIER:id EQUAL expression:e PERIOD3	{ return new VirtualParamNode(t, id.text, e, true); }
			/ type:t IDENTIFIER:id EQUAL expression:e			{ return new VirtualParamNode(t, id.text, e, false); }
			/ type:t IDENTIFIER:id PERIOD3						{ return new VirtualParamNode(t, id.text, null, true); }
			/ type:t IDENTIFIER:id								{ return new VirtualParamNode(t, id.text, null, false); }
			/ IDENTIFIER:id EQUAL expression:e PERIOD3			{ return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, e, true); }
			/ IDENTIFIER:id EQUAL expression:e					{ return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, e, false); }
			/ IDENTIFIER:id PERIOD3								{ return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, null, true); }
			/ IDENTIFIER:id										{ return new VirtualParamNode(new InferenceTypeNode(id.location), id.text, null, false); };
		assoc_array_element_list = { AssocArrayElementNode[] nodes; }
			assoc_array_element:n { nodes ~= n; } (COMMA assoc_array_element:n2 { nodes ~= n2; })* { return nodes; };
		assoc_array_element =
			expression:k COLON expression:v { return new AssocArrayElementNode(k, v); };

		# qualifiers #
		class_qualifier =
			  PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ FINAL:t { return Qualifier(t.location, Qualifiers.Final); }
			/ STATIC:t { return Qualifier(t.location, Qualifiers.Static); };
		trait_qualifier =
		 	 PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ STATIC:t { return Qualifier(t.location, Qualifiers.Static); };
		enum_qualifier =
		 	 PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ STATIC:t { return Qualifier(t.location, Qualifiers.Static); };
		template_qualifier =
			  PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); };
		alias_qualifier =
			  PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); };
		type_qualifier = CONST:t { return Qualifier(t.location, Qualifiers.Const); };
		field_qualifier =
			  PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ PROTECTED:t { return Qualifier(t.location, Qualifiers.Protected); }
			/ STATIC:t { return Qualifier(t.location, Qualifiers.Static); }
			/ FINAL:t { return Qualifier(t.location, Qualifiers.Final); }
			/ CONST:t { return Qualifier(t.location, Qualifiers.Const); };
		method_qualifier =
			  PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ PROTECTED:t { return Qualifier(t.location, Qualifiers.Protected); }
			/ STATIC:t { return Qualifier(t.location, Qualifiers.Static); }
			/ FINAL:t { return Qualifier(t.location, Qualifiers.Final); }
			/ CONST:t { return Qualifier(t.location, Qualifiers.Const); }
			/ OVERRIDE:t { return Qualifier(t.location, Qualifiers.Override); };
		ctor_qualifier =
			  PUBLIC:t { return Qualifier(t.location, Qualifiers.Public); }
			/ PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ PROTECTED:t { return Qualifier(t.location, Qualifiers.Protected); }
			/ CONST:t { return Qualifier(t.location, Qualifiers.Const); };
		lvar_qualifier =
			  PRIVATE:t { return Qualifier(t.location, Qualifiers.Private); }
			/ PROTECTED:t { return Qualifier(t.location, Qualifiers.Protected); }
			/ CONST:t { return Qualifier(t.location, Qualifiers.Const); }
			/ STATIC:t { return Qualifier(t.location, Qualifiers.Static); };

		# types for definition #
		def_id<DefinitionIdentifierNode> =
			  IDENTIFIER:id LBR def_id_arg_list:params RBR { return new DefinitionIdentifierNode(id.location, id.text, params); }
			/ IDENTIFIER:id [LBR RBR] { return new DefinitionIdentifierNode(id.location, id.text, null); };
		def_id_arg_list<DefinitionIdentifierParamNode[]> = { DefinitionIdentifierParamNode[] nodes; }
			def_id_arg:first_t { nodes ~= first_t; } (COMMA def_id_arg:second_t { nodes ~= second_t; })* { return nodes; };
		def_id_arg<DefinitionIdentifierParamNode> =
			def_id_argname:n
			(EQUAL type:t { n = n.withDefaultValue(t); }
				/ COLON type:t { n = n.withExtendedFrom(t); }
				/ RARROW type:t { n = n.withCastableTo(t); })* { return n; };
		def_id_argname = IDENTIFIER:t { return new DefinitionIdentifierParamNode(t.location, t.text); };

		# types for using #
		type<TypeNode> =
			{ auto tq = Qualifier(Location(int.max, int.max), 0); bool hasQualifier = false; }
			(type_qualifier:tqq { tq = tq.combine(tqq); hasQualifier = true; })*
			type_body:tb
			{ return hasQualifier ? new QualifiedTypeNode(tq, tb) : tb; };
		type_body = type_body_base:tbb
			[FUNCTION LP varg_list:vpl RP { tbb = new FunctionTypeNode(tbb, vpl); }
			/ FUNCTION LP RP { tbb = new FunctionTypeNode(tbb, null); }]
			{ return tbb; };
		type_body_base = AUTO:a { return new InferenceTypeNode(a.location); }
			/ restricted_type:rt { return rt; };
		restricted_type<TypeNode> = primitive_types:pt (LBR expression:e RBR { pt = new ArrayTypeNode(pt, e); }
			/ LBR RBR { pt = new ArrayTypeNode(pt, null); })*
			{ return pt; };
		primitive_types<TypeNode> = register_types:rt { return rt; }
			/ template_instance:ti { return ti; }
			/ __typeof:to { return to; };
		__typeof<TypeofNode> =
			TYPEOF:f LP (expression:e RP { return new TypeofNode(f.location, e); }
			/ restricted_type:rt RP { return new TypeofNode(f.location, rt); });
		register_types<RegisterTypeNode> =
			  VOID:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Void); }
			/ CHAR:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Char); }
			/ UCHAR:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Uchar); }
			/ BYTE:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Byte); }
			/ SHORT:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Short); }
			/ USHORT:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Ushort); }
			/ INT:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Int); }
			/ UINT:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Uint); }
			/ LONG:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Long); }
			/ ULONG:t { return new RegisterTypeNode(t.location, RegisterTypeNode.Type.Ulong); };
		template_instance<TemplateInstanceTypeNode> =
			IDENTIFIER:t [template_tail:v { return new TemplateInstanceTypeNode(t.location, t.text, v); }]
			{ return new TemplateInstanceNode(t.location, t.text, null); };
		template_tail<TemplateParamNode[]> =
			  SHARP single_types:st { return [new TemplateParamNode(st.location, st)]; }
			/ SHARP primary_expr:pe { return [new TemplateParamNode(pe.location, pe)]; }
			/ { TemplateParamNode[] params; } SHARP LP template_param:first_t { params ~= first_t; } (COMMA template_param:second_t { params ~= second_t; })* RP { return params; }
			/ SHARP LP RP { return null; };
		template_param<TemplateParamNode> =
			  IDENTIFIER:id { return new TemplateParamNode(id.location, id.text); }
			/ restricted_type:rt { return new TemplateParamNode(rt.location, rt); }
			/ expression:e { return new TemplateParamNode(e.location, e); };
		single_types<TypeNode> =
			  AUTO:a { return new InferenceTypeNode(a.location); }
			/ single_restricted_type:srt { return srt; };
		single_restricted_type<TypeNode> =
			  register_types:rt { return rt; }
			/ IDENTIFIER:t { return new TemplateinstanceNode(t.location, t.text, null); };

		# package paths #
		import_list = import_item (COMMA import_item)*;
		import_item = IDENTIFIER (PERIOD IDENTIFIER)* [PERIOD ASTERISK / PERIOD LB import_list RB];
		package_id<Token[]> = { Token[] ids; }
			IDENTIFIER:t { ids ~= t; } (PERIOD IDENTIFIER:t2 { ids ~= t2; })* { return ids; };
	}
}
